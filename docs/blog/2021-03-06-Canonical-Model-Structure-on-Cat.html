<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>James Leslie - The Canonical Model Structure on Cat/Gpd</title>
        <link rel="stylesheet" href="../css/simple.css" />
        <link rel="stylesheet" href="../css/navbar.css" />
        <link rel="stylesheet" href="../css/misc.css" />
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.2.0/css/all.css">
    </head>
    <body>
           <div class="topnav">
             <a href="../index.html">Home</a>
             <a href="../blog.html">Blog</a>
             <a href="../projects.html">Projects</a>
             <a href="../contact.html">Contact</a>
           </div>

        <main role="main">
            <h1>The Canonical Model Structure on Cat/Gpd</h1>
            <head>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <link rel="stylesheet" href="../css/theorem.css" />
</head>
<section class="header">
  Posted on March  6, 2021
  
  by James Leslie
  
</section>
<section>
  <p>When one first starts studying category theory, they learn that the correct notion of “the same” for categories is that of equivalence, rather than the stronger notion isomorphism. For those that have studied some algebraic topology, the situation is very similar to identifying spaces if they are homotopic, rather than homeomorphic. This is often given as an analogy, but the two notions can be reconciled by giving model structures where the weaker form of identification forms the subcategory of weak equivalences. Here, we define and present the so called canonical model structure on the category of categories. The proof of each step given can also be applied to the category of groupoids.</p>
<p>We denote the category of (small) categories by <span class="math inline">\(\mathbf{Cat}\)</span> and the category of (small) groupoids <span class="math inline">\(\mathbf{Gpd}\)</span>.</p>
<p>This proof can be found on the nLab’s “<a href="https://ncatlab.org/nlab/show/canonical+model+structure+on+Cat">canonical model structure on Cat</a>” page, but here we go into a lot more detail of the constructions.</p>
<h1 id="the-model-structure">The model structure</h1>
<div class="definition">
<p>Let <span class="math inline">\(C\)</span> be a category and <span class="math inline">\((A, B)\)</span> a pair of subcategories. The pair <span class="math inline">\((A, B)\)</span> is a <em>weak factorisation system</em> if:</p>
<ol>
<li>Both <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are stable under retracts;</li>
<li><span class="math inline">\(A\)</span> is in the left lifting class of <span class="math inline">\(B\)</span> (<span class="math inline">\(A \subset LB\)</span>);</li>
<li>Every morphism <span class="math inline">\(f : X \to Y\)</span> in <span class="math inline">\(C\)</span> factors as <span class="math inline">\(f = pi\)</span> with <span class="math inline">\(i \in A\)</span> and <span class="math inline">\(p \in B\)</span>.</li>
</ol>
</div>
<div class="definition">
<p>A <em>model structure</em> on a category <span class="math inline">\(\mathcal{C}\)</span> consists of a triple of wide subcategories <span class="math inline">\(W, F, C \)</span> whose morphisms are called <em>weak equivalences</em> (anotated with a <span class="math inline">\(\sim\)</span>), <em>fibrations</em> (annotated with a double head <span class="math inline">\(\twoheadrightarrow\)</span>) and <em>cofibrations</em> (annotated with a tail <span class="math inline">\(\rightarrowtail\)</span>), respectively. This triple must satisfy the following three axioms:</p>
<ol>
<li><span class="math inline">\(W\)</span> satisfies 2-out-of-3;</li>
<li><span class="math inline">\((F, W \cap C)\)</span> is a weak factorisation system;</li>
<li><span class="math inline">\((F \cap W, C)\)</span> is a weak factorisation system.</li>
</ol>
</div>
<div class="definition">
<p>A <em>model category</em> is a finitely bicomplete category, along with a model structure on it.</p>
</div>
<p>Before giving the main result, we need one more definition.</p>
<div class="definition">
<p>Let <span class="math inline">\(F: \mathcal{A} \to \mathcal{B}\)</span> be a functor. We say <span class="math inline">\(F\)</span> is an <em>isofibration</em> if for every <span class="math inline">\(a \in \mathcal{A}\)</span> and isomorphism <span class="math inline">\(f : Fa \to b \in \mathcal{B}\)</span>, there is an isomorphism <span class="math inline">\(g: a \to a' \in \mathcal{A}\)</span> such that <span class="math inline">\(Ff = g\)</span>.</p>
</div>
<p>Our main result is the following:</p>
<div class="theorem">
<p>The category <span class="math inline">\(\mathbf{Cat}\)</span> has a model structure on it with:</p>
<ol>
<li><span class="math inline">\(W\)</span> being the class of categorical equivalences;</li>
<li><span class="math inline">\(F\)</span> being the class of isofibrations;</li>
<li><span class="math inline">\(C\)</span> being the class of functors injective on objects.</li>
</ol>
</div>
<p>The rest of this section will be proving the above theorem. That <span class="math inline">\(\mathbf{Cat}\)</span> and <span class="math inline">\(\mathbf{Gpd}\)</span> has all finite limits follows from it having a terminal object, binary products and equalisers. The theory of categories and groupoids are generalised algebraic theories, so the category of models (<span class="math inline">\(\mathbf{Cat}\)</span> and <span class="math inline">\(\mathbf{Gpd}\)</span>, respectively) has all (finite) colimits.</p>
<p>We now break down each of the defining features of a model structure and show that they hold here.</p>
<h2 id="out-of-3">2-out-of-3</h2>
<div class="lemma">
<p>Categorical equivalences are closed under 2-out-of-3.</p>
</div>
<div class="proof">
<p>This follows by basic diagram chasing. If we have the following commuting triangle, with any two maps being equivalences, we can take pseudo-inverses to construct a pseudo-inverse to the third map.</p>
</div>
<h2 id="retracts">Retracts</h2>
<div class="lemma">
<p>The class of categorical equivalences is stable under retracts.</p>
</div>
<div class="proof">
<p>Suppose we have the following commuting diagram where <span class="math inline">\(g\)</span> is an equivalence. We show <span class="math inline">\(f\)</span> is also an equivalence:</p>
<p>Since <span class="math inline">\(g\)</span> is an equivalence, there exists a functor <span class="math inline">\(g'\)</span> such that <span class="math inline">\(gg' \cong 1_V\)</span> and <span class="math inline">\(g'g \cong 1_U\)</span>. The morphism <span class="math inline">\(pg'j\)</span> is then easily seen to be a pseudo-inverse to <span class="math inline">\(f\)</span>, showing that it is also an equivalence.</p>
</div>
<div class="lemma">
<p>The class of isofibrations is stable under retracts.</p>
</div>
<div class="proof">
<p>Suppose the following diagram commutes and <span class="math inline">\(g\)</span> is an isofibration. We need to show that <span class="math inline">\(f\)</span> is an isofibration also:</p>
<p>Let <span class="math inline">\(x \in X\)</span> and <span class="math inline">\(\alpha : fx \to y\)</span> be an isomorphism in <span class="math inline">\(Y\)</span>. We apply <span class="math inline">\(j\)</span> to get an isomorphism <span class="math inline">\(j\alpha : jfx=gix \to jy\)</span>. As <span class="math inline">\(g\)</span> is an isofibration, there is an isomorphism <span class="math inline">\(\beta : ix \to u \in U\)</span> such that <span class="math inline">\(g\beta = j\alpha\)</span>. Applying <span class="math inline">\(p\)</span>, we have an isomorphism <span class="math inline">\(p\beta : pix=x \to pu \in X\)</span>. If we apply <span class="math inline">\(f\)</span> to this map, we have:</p>
<span class="math display">\[\begin{align*}
  fp\beta &amp;= qg\beta &amp;&amp; \text{right square}\\
          &amp;= qj\alpha &amp;&amp; \text{definition of }\beta\\
          &amp;= \alpha.
\end{align*}
\]</span>
<p>Hence, given an isomorphism <span class="math inline">\(\alpha\)</span>, there exists an isomorphism <span class="math inline">\(p\beta\)</span> such that <span class="math inline">\(fp\beta = \alpha\)</span>, so <span class="math inline">\(f\)</span> is also an isofibration.</p>
</div>
<div class="lemma">
<p>The class of functors injective on objects is stable under retracts.</p>
</div>
<div class="proof">
<p>Suppose we have the following diagram in <span class="math inline">\(\mathbf{Cat}\)</span>, where <span class="math inline">\(g\)</span> is a functor injective on objects. We need to show that <span class="math inline">\(f\)</span> is injective on objects also:</p>
<p>Suppose <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> are objects in <span class="math inline">\(X\)</span> such that <span class="math inline">\(fx = fy\)</span>. We have the following chain of equalities:</p>
<span class="math display">\[\begin{align*}
  fx = fy &amp;\implies jfx=jfy\\
          &amp;\implies gix=giy &amp;&amp; \text{(left square)}\\
          &amp;\implies ix=iy &amp;&amp; (g \in C)\\
          &amp;\implies pix=piy\\
          &amp;\implies x=y.
\end{align*}
\]</span>
<p>Hence <span class="math inline">\(f\)</span> is also injective on objects.</p>
</div>
<h2 id="lifting-properties">Lifting properties</h2>
<p>We first give a lemma that will be useful in solving the lifting problems in this section.</p>
<div class="lemma">
<p>Isofibrations that are equivalences are exactly the equivalences that are surjective on objects.</p>
</div>
<div class="proof">
<p>Suppose that <span class="math inline">\(F: \mathcal{A} \to \mathcal{B}\)</span> is an isofibration and an equivalence. To see that it is surjective on objects, let <span class="math inline">\(b \in B\)</span>. As <span class="math inline">\(F\)</span> is an equivalence, it is fully faithful, so there is some <span class="math inline">\(a \in \mathcal{A}\)</span> and isomorphism <span class="math inline">\(\beta : Fa \to b \in \mathcal{B}\)</span>. As <span class="math inline">\(F\)</span> is an isofibration, there is an isomorphism <span class="math inline">\(\alpha : a \to a' \in \mathcal{A}\)</span> such that <span class="math inline">\(F\alpha = \beta\)</span>. Then, we must have that <span class="math inline">\(Fa' = b\)</span>, so <span class="math inline">\(F\)</span> is surjective on objects.</p>
<p>If <span class="math inline">\(F\)</span> is an equivalence that is surjective on objects, it is also an isofibration. Let <span class="math inline">\(a \in \mathcal{A}\)</span> and <span class="math inline">\(\beta : Fa \to b\)</span> be an isomorphism in <span class="math inline">\(\mathcal{B}\)</span>. As <span class="math inline">\(F\)</span> is surjective on objects, <span class="math inline">\(b = Fa'\)</span> for some <span class="math inline">\(a' \in \mathcal{A}\)</span>, so <span class="math inline">\(\beta\)</span> is a map <span class="math inline">\(Fa \to Fa'\)</span>. By <span class="math inline">\(F\)</span> being full, there is a morphism <span class="math inline">\(\alpha : a \to a'\)</span> such that <span class="math inline">\(F\alpha = \beta\)</span>. By <span class="math inline">\(F\)</span> being faithful, this <span class="math inline">\(\alpha\)</span> must be an isomorphism, so <span class="math inline">\(F\)</span> is an isofibration.</p>
</div>
<div class="lemma">
<p>The class of functors injective on objects has the left lifting property with respect to functors that are isofibrations and equivalences.</p>
</div>
<div class="proof">
<p>Suppose we have the following commuting diagram, where <span class="math inline">\(f\)</span> is injective on objects and <span class="math inline">\(g\)</span> is an equivalence and isofibration:</p>
<p>As this commutes, we have the following ``object square’’ commuting in <span class="math inline">\(\mathbf{Set}\)</span>:</p>
<p>In particular, <span class="math inline">\(f_0\)</span> is injective and by Lemma 10, <span class="math inline">\(g_0\)</span> is surjective. As <span class="math inline">\((\text{inj}, \text{surj})\)</span> form a weak factorisation system on <span class="math inline">\(\mathbf{Set}\)</span>, there is a lift <span class="math inline">\(h_0\)</span>. We now aim to turn <span class="math inline">\(h_0\)</span> into a functor. Let <span class="math inline">\(\alpha: y \to y'\)</span> be a morphism in <span class="math inline">\(Y\)</span>. We then have a morphism <span class="math inline">\(j\alpha : jy = gh_0y \to gh_0y'=jy' \in V_0\)</span>. As <span class="math inline">\(g\)</span> is fully faithful, there is a unique morphism <span class="math inline">\(\beta : h_0 y \to h_0 y' \in U\)</span> such that <span class="math inline">\(g\beta = j\alpha\)</span>. We define <span class="math inline">\(h\alpha := \beta\)</span>. As <span class="math inline">\(j\)</span> is a functor, it must preserve identity morphisms and as <span class="math inline">\(g\)</span> is fully faithful, the lift of an identity morphism from <span class="math inline">\(v\)</span> to <span class="math inline">\(u\)</span> must be the identity, so <span class="math inline">\(h\)</span> preserves identity morphisms. Similarly, by functorality of <span class="math inline">\(j\)</span> and fully faithfulness of <span class="math inline">\(g\)</span>, we have that composites are mapped to composites, so <span class="math inline">\(h\)</span> is a functor and makes the bottom triangle commute:</p>
<p>The top triangle commutes on objects, so we need to check it commutes on maps. Given <span class="math inline">\(\alpha : x \to x' \in X\)</span>,</p>
<span class="math display">\[\begin{align*}
  g i \alpha &amp;= j f \alpha\\
             &amp;= g h f \alpha
\end{align*}
\]</span>
<p>So <span class="math inline">\(i \alpha = h f \alpha\)</span> by fully faithfulness of <span class="math inline">\(g\)</span>, meaning that the top triangle commutes. This means that <span class="math inline">\(h\)</span> is indeed a lift, which shows that functors injective on objects are in the left lifting class of fucntors that are equivalences and isofibrations.</p>
</div>
<div class="lemma">
<p>The class of functors injective on objects which are also equivalences has the left lifting property with respect to functors that are isofibrations.</p>
</div>
<div class="proof">
<p>Suppose we have the following diagram commuting, with <span class="math inline">\(f\)</span> an equivalence that is injective on objects and <span class="math inline">\(g\)</span> an isofibration:</p>
<p>To construct a functor <span class="math inline">\(h:Y \to U\)</span>, we use the axiom of choice to get some extra structure. As <span class="math inline">\(f\)</span> is essentially surjective, for every object <span class="math inline">\(y \in Y\)</span>, we choose an isomorphism <span class="math inline">\(\alpha_y : fx_y \to y\)</span>, picking the identity morphism wherever possible, i.e <span class="math inline">\(\alpha_{fx} = 1_{fx}\)</span> (we call the argument of <span class="math inline">\(f\)</span> <span class="math inline">\(x_y\)</span>, which is well defined at <span class="math inline">\(f\)</span> is injective on objects). As <span class="math inline">\(g\)</span> is an isofibration, we choose for every <span class="math inline">\(y \in Y\)</span> a morphism <span class="math inline">\(\beta_y : ix_y \to u_y \in U\)</span> such that <span class="math inline">\(g\beta_y = j\alpha_y\)</span>, again, picking the identity morphism whenever possible, i.e <span class="math inline">\(\beta_{fx} = 1_{ix}\)</span>. On objects, we define <span class="math inline">\(h(y) = u_y\)</span>. For morphisms, the output is a little more complicated. Starting with a map <span class="math inline">\(\gamma : y \to y'\)</span>, we form the composite <span class="math inline">\(\alpha_{y'}^{-1} \gamma \alpha_y : fx_y \to fx_{y'}\)</span>. We let <span class="math inline">\(\overline{\alpha_{y'}^{-1} \gamma \alpha_y} : x_y \to x_{y'}\)</span> be the unique map that <span class="math inline">\(f\)</span> maps to <span class="math inline">\(\alpha_{y'}^{-1} \gamma \alpha_y\)</span>. Then, applying <span class="math inline">\(i\)</span>, we have a map <span class="math inline">\(i \overline{\alpha_{y'}^{-1} \gamma \alpha_y} : ix_y \to ix_{y'}\)</span>. We can then compose with maps <span class="math inline">\(\beta_y^{-1}\)</span> and <span class="math inline">\(\beta_{y'}\)</span> to get <span class="math inline">\(\beta_{y'} i \left(\overline{\alpha_{y'}^{-1} \gamma \alpha_y}\right) \beta_{y}^{-1} : u_y \to u_{y'}\)</span>. This is what we define <span class="math inline">\(h\gamma\)</span> to be.</p>
<p>To see that <span class="math inline">\(h\)</span> is a functor, we see that it sends the identity to the identity:</p>
<span class="math display">\[\begin{align*}
  \beta_{y} i \left(\overline{\alpha_{y}^{-1} 1_y \alpha_y}\right) \beta_{y}^{-1} &amp;= \beta_y i\left( \overline{1_y}\right) \beta_y^{-1} \\
  &amp;= \beta_y i(1_{x_y}) \beta_y^{-1}\\
  &amp;=1_{u_y}.
\end{align*}
\]</span>
<p>We also see that <span class="math inline">\(h\)</span> preserves composites: let <span class="math inline">\(\gamma : y \to y'\)</span> and <span class="math inline">\(\delta : y' \to y''\)</span>. Then:</p>
<span class="math display">\[\begin{align*}
  \beta_{y''} i \left(\overline{\alpha_{y''}^{-1} \delta \alpha_{y'}}\right) \beta_{y'}^{-1} \circ \beta_{y'} i \left(\overline{\alpha_{y'}^{-1}\gamma \alpha_y}\right) \beta_y^{-1} &amp;=  \beta_{y''} i \left( \overline{\alpha_{y''}^{-1} \delta \alpha_{y'}}\right) i \left( \overline{\alpha_{y'}^{-1}\gamma \alpha_y}\right) \beta_y^{-1}\\
                                                                                                                                                                                     &amp;= \beta_{y''}i \left( \overline{\alpha_{y''}^{-1} \delta \alpha_{y'}} \circ \overline{\alpha_{y'}^{-1} \gamma \alpha_y} \right) \beta_y^{-1}\\
  &amp;= \beta_{y''} i \left( \alpha^{-1}_{y''} \delta \gamma \alpha_y \right) \beta_y^{-1}
\end{align*}
\]</span>
<p>We now show that it makes both the triangles commute:</p>
<p>Given <span class="math inline">\(x \in X\)</span>, we need <span class="math inline">\(ix = u_{fx}\)</span>, however this follows from our choice of maps being the identity wherever possible, which means <span class="math inline">\(\beta_{fx} = 1_{ix}\)</span>. Likewise, for maps <span class="math inline">\(\gamma: x \to x'\)</span>, our chosen isomorphisms are the identity, giving <span class="math inline">\(hf\gamma = i\gamma\)</span>. Now, if <span class="math inline">\(y \in Y\)</span>, we see by definition that <span class="math inline">\(gu_y = jy\)</span>, so the bottom triangle commutes on objects. Given a map <span class="math inline">\(\gamma : y \to y' \in Y\)</span>, by the properties of <span class="math inline">\(\beta_y\)</span> we have:</p>
<span class="math display">\[\begin{align*}
  g\left( \beta_{y'} i \left(\overline{\alpha_{y'}^{-1} \gamma \alpha_y}\right) \beta_{y}^{-1} \right) &amp;= g(\beta_{y'}) gi \left(\overline{\alpha_{y'}^{-1} \gamma \alpha_y}\right) g(\beta_{y})^{-1}\\
                                                                                                         &amp;= j(\alpha_{y'}) jf \left( \overline{\alpha_{y'}^{-1} \gamma \alpha_y} \right) j(\alpha_y)^{-1}\\
                                                                                                         &amp;= j(\alpha_{y'}) j(\alpha_{y'})^{-1} j\gamma j(\alpha_y) j(\alpha_y)^{-1}\\
                                                                                                         &amp;=j\gamma
\end{align*}
\]</span>
<p>Hence <span class="math inline">\(h\)</span> is a lift, as required.</p>
</div>
<h2 id="factorisations">Factorisations</h2>
<div class="lemma">
<p>Every functor can be factored as a functor injective on objects, followed by a functor that is an isofibration and equivalence.</p>
</div>
<div class="proof">
<p>Given <span class="math inline">\(f:X \to Y\)</span>, we form a new category <span class="math inline">\(Z\)</span> with objects given by <span class="math inline">\(X_0 \coprod Y_0\)</span>. We define the hom-sets as follows:</p>
<span class="math display">\[\begin{align*}
  Z(x,y) := \begin{cases}
    x \in X, y \in X &amp;\implies Y(fx, fy),\\
    x \in X, y \in Y &amp;\implies Y(fx, y),\\
    x \in Y, y \in X &amp;\implies Y(x, fy),\\
    x \in Y, y \in Y &amp;\implies Y(x, y).
  \end{cases}
\end{align*}
\]</span>
<p>We then have a functor <span class="math inline">\(X \to Z\)</span> which is the identity on objects, and <span class="math inline">\(f\)</span> on maps, which, in particular, is injective on objects. We can also construct another functor <span class="math inline">\(Z \to Y\)</span> which is formed by applying <span class="math inline">\(f\)</span> to objects from <span class="math inline">\(X\)</span> and the identity to objects from <span class="math inline">\(y\)</span>. It is then the identity morphism on maps, which means it is fully faithful. It is also surjective on objects as every object in <span class="math inline">\(Y\)</span> is mapped to itself by this functor. The composite of these two morphisms is <span class="math inline">\(f\)</span> on objects and <span class="math inline">\(f\)</span> on maps, hence it is a factorisation of <span class="math inline">\(f\)</span> into a functor injective on objects, followed by a surjective equivalence (which by Lemma 10) is an equivalence and isofibration), as required.</p>
</div>
<div class="lemma">
<p>Every functor can be factored as a functor injective on objects and an equivalence, followed by an isofibration.</p>
</div>
<div class="proof">
<p>Given <span class="math inline">\(f:X \to Y\)</span> we form the comma category <span class="math inline">\(F \downarrow 1_Y\)</span>, then take the full subcategory spanned by objects <span class="math inline">\((x, y, \phi : fx \to y)\)</span> where <span class="math inline">\(\phi\)</span> is an isomorphism in <span class="math inline">\(Y\)</span>. Denote this category as <span class="math inline">\(F \downarrow_{\cong} 1_Y\)</span>
Note that we have a functor <span class="math inline">\(X \to F \downarrow_{\cong} 1_Y\)</span> defined by sending <span class="math inline">\(x \mapsto (x , fx, 1_{fx})\)</span> and <span class="math inline">\(\alpha : x \to x' \mapsto (\alpha, f\alpha)\)</span>. This is clearly injective on objects and fully faithful. We also have that every <span class="math inline">\((x, y, \phi) \cong (x, fx, 1_{fx})\)</span> by the following commuting square in <span class="math inline">\(Y\)</span> (with horizontal maps being isomorphisms):</p>
<p>We have a functor <span class="math inline">\(f \downarrow_{\cong} 1_Y \to Y\)</span> given by projecting out the second component. This functor is also seen to be an isofibration: given <span class="math inline">\((x, y, \phi)\)</span> and an isomorphism <span class="math inline">\(\alpha : y \to y' \in Y\)</span>, the following square commutes, with horizontal maps isomorphisms, so is an isomorphism in <span class="math inline">\(f \downarrow_{\cong} 1_Y\)</span>:</p>
<p>Our projection functor sends this isomorphism to <span class="math inline">\(\alpha\)</span>, so it is an isofibration. The composite of the two functors defined is easily seen to be equal to <span class="math inline">\(f\)</span>, completing the factorisation of <span class="math inline">\(f\)</span> as an equivalence that is injective on objects, followed by an isofibration.</p>
</div>
<h1 id="putting-it-all-together">Putting it all together</h1>
<div class="corollary">
<p>Functors injective on objects and equivalences that are isofibrations, form a weak factorisation system on <span class="math inline">\(\mathbf{Cat}\)</span>.</p>
</div>
<div class="proof">
<p>Lemma 9 shows functors injective on objects are stable under retracts. Lemmas 9 and 9 show that equivalences that are isofibrations are also stable under retracts. Lemma 13 gives the desired lifting data and Lemma 14 gives the desired factorisation.</p>
</div>
<div class="corollary">
<p>Equivalences that are injective on objects and isofibrations form a weak factorisation system on <span class="math inline">\(\mathbf{Cat}\)</span>.</p>
</div>
<div class="proof">
<p>Lemmas 7 and 9 show that the class of equivalences that are injective on objects is stable under retracts. Lemma 8 shows the class of isofibrations are stable under retracts. Lemma 12 gives the desired lifting data and Lemma 14 gives the desired factorisation.</p>
</div>
<div class="corollary">
<p>The category <span class="math inline">\(\mathbf{Cat}\)</span> has a model structure on it with:</p>
<ol>
<li><span class="math inline">\(W\)</span> being the class of equivalences;</li>
<li><span class="math inline">\(F\)</span> being the class of isofibrations;</li>
<li><span class="math inline">\(C\)</span> being the class of functors injective on objects.</li>
</ol>
</div>
<div class="proof">
<p>Lemma shows that <span class="math inline">\(W\)</span> satisfies 2-out-of-3. Corollaries 15 and 16 show that <span class="math inline">\((C \cap W, F)\)</span> and <span class="math inline">\((C, F \cap W)\)</span> are weak factorisation systems.</p>
</div>
<p>This proves Theorem 5. To see that this restricts to <span class="math inline">\(\mathbf{Gpd}\)</span> we only need to realise that if <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> are groupoids, the categories constructed in the Factorisations section are also groupoids. This means we have the following:</p>
<div class="corollary">
<p>The category <span class="math inline">\(\mathbf{Gpd}\)</span> has a model structure on it with:</p>
<ol>
<li><span class="math inline">\(W\)</span> being the class of categorical equivalences;</li>
<li><span class="math inline">\(F\)</span> being the class of isofibrations;</li>
<li><span class="math inline">\(C\)</span> being the class of functors injective on objects.</li>
</ol>
</div>
</section>
<hr>
<script src="https://giscus.app/client.js" data-repo="jeslie0/jeslie0.github.io" data-repo-id="R_kgDOG3FkcQ" data-category="Announcements" data-category-id="DIC_kwDOG3Fkcc4CPMWW" data-mapping="title" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" data-loading="lazy" crossorigin="anonymous" async>
</script>
</article>

        </main>

        <footer>
          <p>Site made with love using <a href="https://orgmode.org/">org-mode</a> and <a href="https://jaspervdj.be/hakyll">Hakyll</a></p>
          <p><a href="../rss.xml"> <i class="fas fa-rss-square"></i></a></p>
          <p>Page updated with commit: 9a15c40: Converting blog to Hakyll (2022-03-02 13:56:50 +0000)</p>
        </footer>
    </body>
</html>
