<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>James Leslie - Yoneda, Yoneda, Yoneda</title>
    <link rel="stylesheet" href="../css/simple.css" />
    <link rel="stylesheet" href="../css/navbar.css" />
    <link rel="stylesheet" href="../css/misc.css" />
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.2.0/css/all.css">
  </head>
  <body>
    <div class="topnav">
  <a href="../index.html">Home</a>
  <a href="../blog.html">Blog</a>
  <a href="projects.html">Projects</a>
  <a href="../contact.html">Contact</a>
</div>

    <main role="main">
      <h1>Yoneda, Yoneda, Yoneda</h1>
      <head>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <link rel="stylesheet" href="../css/theorem.css" />
</head>
<section class="header">
  Posted on April 23, 2018
  
  by James Leslie
  
</section>
<section>
  <p>The Yoneda Lemma is one of the few ‘theorems’ one learns in a first course on category theory and it is an invaluable tool.</p>
<p>Suppose we have a locally small category <span class="math inline">\( \mathcal{A}\)</span>, then for any two objects <span class="math inline">\( A, B\)</span> there is a set of maps from <span class="math inline">\( A\)</span> to <span class="math inline">\( B\)</span>, denoted <span class="math inline">\( \mathcal{A}(A,B)\)</span>. We can make this into a functor by forgetting about the domain. We define the following functor:</p>
<p><span class="math inline">\( H_B:\mathcal{A}^{op} \rightarrow \mathbf{Set}\)</span>,</p>
<p>such that <span class="math inline">\( A \mapsto H_B(A) = \mathcal{A}(A, B)\)</span> and <span class="math inline">\((f:A \rightarrow C) \mapsto (H_A(f):H_A(C) \rightarrow H_A(A))\)</span>. Given any map <span class="math inline">\( g:C \rightarrow A\)</span>, <span class="math inline">\( (H_A(f))(g) = g \circ f:A \rightarrow A\)</span>. We can go further however, by removing our choice of <span class="math inline">\(A\)</span>. We define a functor</p>
<p><span class="math inline">\(H_\cdot:\mathcal{A} \rightarrow [\mathcal{A}^\text{op}, \mathbf{Set}]\)</span>,</p>
<p>where <span class="math inline">\( A \mapsto H_A\)</span> and <span class="math inline">\( (f:A \rightarrow B) \mapsto (H_f:H_A \rightarrow H_B)\)</span>, where <span class="math inline">\( H_f\)</span> is a natural transformation. For any <span class="math inline">\( C \in \mathcal{A}\)</span>, the <span class="math inline">\( C\)</span> component of <span class="math inline">\( H_f\)</span> is a function <span class="math inline">\( (H_f)_C:H_A(C) \rightarrow H_B(C)\)</span> such that for any map <span class="math inline">\( g:C \rightarrow A\)</span>, <span class="math inline">\( ((H_f)_C)(g) = f \circ g:C \rightarrow B\)</span>.</p>
<p>The functor <span class="math inline">\( H_\cdot\)</span> is known as the Yoneda embedding. It comes hand in hand with the Yoneda Lemma.</p>
<h1 id="yoneda-lemma">Yoneda lemma</h1>
<div class="theorem">
<p>Let <span class="math inline">\(\mathcal{A}\)</span> be a locally small category. Then </p>
<p><span class="math inline">\([\mathcal{A}^\text{op}, \mathbf{Set}](H_A, X) \cong X(A)\)</span>,</p>
<p>naturally in <span class="math inline">\(A \in \mathcal{A}\)</span> and <span class="math inline">\( X \in  [\mathcal{A}^\text{op}, \mathbf{Set}]\)</span>.</p>
</div>
<p>There are many discussions on the importance of Yoneda, however we shall skip over them and instead look at the Yoneda embedding. This functor can only really be called an embedding if it is both full and faithful. This is a trivial result of the Yoneda lemma, however it is not necessary to invoke the lemma and it can be proven without it.</p>
<h1 id="yoneda-embedding-is-full-and-faithful">Yoneda embedding is full and faithful</h1>
<p>Let <span class="math inline">\( A, A' \in \mathcal{A}\)</span>, and let <span class="math inline">\( \alpha:H_A \rightarrow H_{A'}\)</span> be a natural transformation. We need to find a map <span class="math inline">\( f:A \rightarrow A'\)</span> such that <span class="math inline">\( \alpha = H_f\)</span>. Looking at the <span class="math inline">\( A\)</span> component of <span class="math inline">\( \alpha\)</span> gives us a function</p>
<p><span class="math inline">\(\alpha_A:H_A(A) \rightarrow H_{A'}(A)\)</span>.</p>
<p>We apply this to the identity map on <span class="math inline">\( A\)</span> to get a map <span class="math inline">\( \alpha_A(1_A):A \rightarrow A'\)</span>. I claim that this is the required map. For notation, we shall call it <span class="math inline">\( f\)</span>. It is the case that <span class="math inline">\( H_f = \alpha\)</span> if and only if each component is equal, that is <span class="math inline">\( (H_f)_B = \alpha_B\)</span> for all objects <span class="math inline">\( B \in \mathcal{A}\)</span>. Choosing an arbitrary <span class="math inline">\( B \in \mathcal{A}\)</span>, as both  <span class="math inline">\( (H_f)_B\)</span> and <span class="math inline">\( \alpha_B\)</span> are functions, they are equal if and only if they take the same values on the same inputs. Recall the domains and codomains of the functions:</p>
<p><span class="math inline">\((H_f)_B, \alpha_B: H_A(B) \rightarrow H_{A'}(B)\)</span>.</p>
<p>Take an arbitrary map <span class="math inline">\( g:B \rightarrow A\)</span>. Then <span class="math inline">\( ((H_f)_B)(g) = f \circ g = \alpha_A(1_A) \circ g\)</span>. We need to show that this is <span class="math inline">\( \alpha_B(g)\)</span>. This follows from the naturality of <span class="math inline">\( \alpha\)</span>. Indeed, for naturality gives us the following commutative square:</p>
<p><span class="math display">\[\begin{tikzcd}
H_A(A) \arrow[r, &quot;- \circ g&quot;] \arrow[d, &quot;\alpha_A&quot;'] &amp; H_A(B) \arrow[d, &quot;\alpha_B&quot;] \\
H_{A'}(A) \arrow[r, &quot;-\circ g&quot;']                     &amp; H_A'(B)                     
\end{tikzcd}\]</span></p>
<p>These functions take the following on <span class="math inline">\( 1_A\)</span>:</p>
<p><span class="math display">\[\begin{tikzcd}
1_A \arrow[dd, maps to] \arrow[r, maps to] &amp; g \arrow[d, maps to]  \\
                                           &amp; \alpha_B(g)           \\
\alpha_A(1_A) \arrow[r, maps to]           &amp; \alpha_A(1_A) \circ g
\end{tikzcd}\]</span></p>
<p>This says that <span class="math inline">\( \alpha_B(g) = \alpha_A(1_A) \circ g\)</span>. This means <span class="math inline">\( \alpha_B\)</span> and <span class="math inline">\( (H_f)_B\)</span> are equal as functions, which means that <span class="math inline">\( H_f = \alpha\)</span>. which by our reasoning above shows that <span class="math inline">\( \alpha = H_f\)</span>, hence <span class="math inline">\( H_\cdot\)</span> is full.</p>
<p>For faithfulness, again fix <span class="math inline">\( A, A' \in \mathcal{A}\)</span> and consider two natural transformations <span class="math inline">\( H_f, H_g: H_A \rightarrow H_A'\)</span>. Supposing <span class="math inline">\( H_f = H_g\)</span>, we need to show that <span class="math inline">\( f=g\)</span>. As <span class="math inline">\( H_f = H_g\)</span>, <span class="math inline">\( (H_f)_A = (H_g)_A)\)</span>. These are both functions, so we apply them to <span class="math inline">\( 1_A\)</span> giving us <span class="math inline">\( f \circ 1_A = g \circ 1_A\)</span>, therefore <span class="math inline">\( f = g\)</span>, proving faithfulness.</p>
<p>Despite not explicitly using the Yoneda lemma, everything we have done is used in the proof of it. There is one more result that helps capture the idea behind the proof for Yoneda.</p>
<h1 id="yoneda-embedding-is-injective-on-isomorphism-classes">Yoneda embedding is injective on isomorphism classes</h1>
<p>Suppose for two objects <span class="math inline">\( A, B \in \mathcal{A}\)</span> that <span class="math inline">\( H_A \cong H_{B}\)</span>. This means that we have two natural isomorphisms:</p>
<p><span class="math inline">\(\alpha:H_A \rightarrow H_B, \qquad \beta:H_B \rightarrow H_A\)</span></p>
<p>which are inverses to each other. By reasoning from above, we a map <span class="math inline">\( \alpha_A(1_A):A \rightarrow B\)</span> and <span class="math inline">\( \beta_B(1_B):B \rightarrow A\)</span>. For notation, we shall call <span class="math inline">\( \alpha_A(1_A) = f\)</span> and <span class="math inline">\( \beta_B(1_B) = g\)</span>. Again from above, we see that <span class="math inline">\( \alpha_B(g) = \alpha_A(1_A) \circ g\)</span>. Substituting for <span class="math inline">\( g\)</span> gives that <span class="math inline">\( \alpha_B(\beta_B(1_B)) = \alpha_A(1_A) \circ \beta_B(1_B)\)</span>. As <span class="math inline">\( \alpha\)</span> and <span class="math inline">\( \beta\)</span> are inverses, their components are mutual inverses. This means <span class="math inline">\( \alpha_B(\beta_B(1_B)) = 1_B\)</span>, so <span class="math inline">\( \alpha_A(1_A) \circ \beta_B(1_B) = 1_B\)</span>. A similar argument shows that <span class="math inline">\( \beta_B(1_B) \circ \alpha_A(1_A) = 1_A\)</span>, hence <span class="math inline">\( \alpha_A(1_A)\)</span> and <span class="math inline">\( \beta_B(1_B)\)</span> are isomorphisms. Therefore, <span class="math inline">\( A \cong B\)</span>.</p>
<p>The results from this post are from Chapter 4 of Tom Leinster’s Basic Category Theory textbook, which can be found <a href="https://arxiv.org/abs/1612.09375">here</a>.</p>
</section>
<hr>
<script src="https://giscus.app/client.js" data-repo="jeslie0/jeslie0.github.io" data-repo-id="R_kgDOG3FkcQ" data-category="Announcements" data-category-id="DIC_kwDOG3Fkcc4CPMWW" data-mapping="title" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" data-loading="lazy" crossorigin="anonymous" async>
</script>

</article>

    </main>

    <footer>
      <p>Site made with love using <a href="https://orgmode.org/">org-mode</a> and <a href="https://jaspervdj.be/hakyll">Hakyll</a></p>
      <p><a href="../rss.xml"> <i class="fas fa-rss-square"></i></a></p>
      <p>Page updated with commit: 9a15c40: Converting blog to Hakyll (2022-03-02 13:56:50 +0000)</p>
    </footer>
  </body>
</html>
