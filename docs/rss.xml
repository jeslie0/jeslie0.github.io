<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>James Leslie's Blog</title>
        <link>https://jeslie0.github.com</link>
        <description><![CDATA[This feed provides my blog posts!]]></description>
        <atom:link href="https://jeslie0.github.com/rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Tue, 08 Jun 2021 00:00:00 UT</lastBuildDate>
        <item>
    <title>Stoicism and raising a puppy</title>
    <link>https://jeslie0.github.com/blog/2021-06-08-Stoicism-and-raising-a-puppy.html</link>
    <description><![CDATA[<head>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <link rel="stylesheet" href="/css/theorem.css" />
</head>
<section class="header">
  Posted on June  8, 2021
  
  by James Leslie
  
</section>
<section>
  <p>A month or two ago, my girlfriend, her brother and I went for a drive and came back with a puppy. My girlfriend had been wanting a puppy for many years; now that the day had come where she would get to take one home, she was beaming more than ever. When I lived in Scotland, my family raised and loved a yellow labrador (named Bobby), so I knew what to expect from the coming months. Or so I thought. Bobby came into my life when I was a mere 10 years old, so most of my memories of him are from the later stages in his life. My parents’ memories of this time will probably be better than mine. I have the occasional memory of Bobby chewing on the skirting boards and urinating behind the sofa, but apart from that, he is a dream dog in my mind.</p>
<p>The new puppy (Woody) makes me doubt the integrity of my previous memories. Woody is a chocolate labrador, with an apt name. Anything in our vicinity made of wood will end up suffering the misfortune of being chewed on. The list of casualties includes chairs, desks, tables, skirting boards, book shelves, notebooks and, of course, twigs and branches. This is only the list of his wooden feasts. Woody also has a real taste for plastic and metal, which unfortunately we found out when he chewed his way through my girlfriend’s bike’s chain guard.</p>
<p>This brings me to my first reflection on Stoicism. Keeping a puppy that tries to destroy everything in reach reminded me of the temporary nature of belongings. It is far too easy to forget that even though we purchase items, they don’t last forever. Even if they do out last us, we don’t take them with us. We should appreciate what we have while we have it.</p>
<p>My second reflection is about anger. Before Woody came into my life, I thought that I was very hard to anger: I can’t remember a recent time that felt really angry. Now though, it seems like every day my anger rises to the surface. This usually happens when Woody thinks it’s a good idea to go around trying to eat everything in the house, including computer cables. When this happens, I have a real desire to punish Woody, but really this is only anger trying to take control. Punishment in the form of yelling or hitting serves no good, even in trying to get Woody’s behaviour to change. Some say that it can even reinforce the behaviour. The only reason I have a desire to punish him is because of the anger that bubbles up. The only purpose it serves is as a release for me. I need to accept that chewing is a part of his nature, especially now that he is teething. The best thing to do is to try and redirect his attention to one of his many toys, designed for withstanding his mighty chomp. When he can’t be redirected, it’s time for him to sleep.</p>
<p>When my girlfriend and I were planning living with a new dog, I didn’t think that Stoic values would be an important factor in raising it. I am glad that I was wrong.</p>
<p>Attached is a picture of the (not so little) Woody. Today, he has been a real star of a puppy and as I type this, he is fast asleep in his bed.</p>
<p><img src="../images/woody.jpeg" class="rounded corners" width="300" /></p>
</section>
<hr>
<script src="https://giscus.app/client.js"
        data-repo="jeslie0/jeslie0.github.io"
        data-repo-id="R_kgDOG3FkcQ"
        data-category="Announcements"
        data-category-id="DIC_kwDOG3Fkcc4CPMWW"
        data-mapping="title"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="light"
        data-lang="en"
        data-loading="lazy"
        crossorigin="anonymous"
        async>
</script>

</article>
]]></description>
    <pubDate>Tue, 08 Jun 2021 00:00:00 UT</pubDate>
    <guid>https://jeslie0.github.com/blog/2021-06-08-Stoicism-and-raising-a-puppy.html</guid>
    <dc:creator>James Leslie</dc:creator>
</item>
<item>
    <title>The Canonical Model Structure on Cat/Gpd</title>
    <link>https://jeslie0.github.com/blog/2021-03-06-Canonical-Model-Structure-on-Cat.html</link>
    <description><![CDATA[<head>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <link rel="stylesheet" href="/css/theorem.css" />
</head>
<section class="header">
  Posted on March  6, 2021
  
  by James Leslie
  
</section>
<section>
  <p>When one first starts studying category theory, they learn that the correct notion of “the same” for categories is that of equivalence, rather than the stronger notion isomorphism. For those that have studied some algebraic topology, the situation is very similar to identifying spaces if they are homotopic, rather than homeomorphic. This is often given as an analogy, but the two notions can be reconciled by giving model structures where the weaker form of identification forms the subcategory of weak equivalences. Here, we define and present the so called canonical model structure on the category of categories. The proof of each step given can also be applied to the category of groupoids.</p>
<p>We denote the category of (small) categories by <span class="math inline">\(\mathbf{Cat}\)</span> and the category of (small) groupoids <span class="math inline">\(\mathbf{Gpd}\)</span>.</p>
<p>This proof can be found on the nLab’s “<a href="https://ncatlab.org/nlab/show/canonical+model+structure+on+Cat">canonical model structure on Cat</a>” page, but here we go into a lot more detail of the constructions.</p>
<h1 id="the-model-structure">The model structure</h1>
<div class="definition">
<p>Let <span class="math inline">\(C\)</span> be a category and <span class="math inline">\((A, B)\)</span> a pair of subcategories. The pair <span class="math inline">\((A, B)\)</span> is a <em>weak factorisation system</em> if:</p>
<ol>
<li>Both <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are stable under retracts;</li>
<li><span class="math inline">\(A\)</span> is in the left lifting class of <span class="math inline">\(B\)</span> (<span class="math inline">\(A \subset LB\)</span>);</li>
<li>Every morphism <span class="math inline">\(f : X \to Y\)</span> in <span class="math inline">\(C\)</span> factors as <span class="math inline">\(f = pi\)</span> with <span class="math inline">\(i \in A\)</span> and <span class="math inline">\(p \in B\)</span>.</li>
</ol>
</div>
<div class="definition">
<p>A <em>model structure</em> on a category <span class="math inline">\(\mathcal{C}\)</span> consists of a triple of wide subcategories <span class="math inline">\(W, F, C \)</span> whose morphisms are called <em>weak equivalences</em> (anotated with a <span class="math inline">\(\sim\)</span>), <em>fibrations</em> (annotated with a double head <span class="math inline">\(\twoheadrightarrow\)</span>) and <em>cofibrations</em> (annotated with a tail <span class="math inline">\(\rightarrowtail\)</span>), respectively. This triple must satisfy the following three axioms:</p>
<ol>
<li><span class="math inline">\(W\)</span> satisfies 2-out-of-3;</li>
<li><span class="math inline">\((F, W \cap C)\)</span> is a weak factorisation system;</li>
<li><span class="math inline">\((F \cap W, C)\)</span> is a weak factorisation system.</li>
</ol>
</div>
<div class="definition">
<p>A <em>model category</em> is a finitely bicomplete category, along with a model structure on it.</p>
</div>
<p>Before giving the main result, we need one more definition.</p>
<div class="definition">
<p>Let <span class="math inline">\(F: \mathcal{A} \to \mathcal{B}\)</span> be a functor. We say <span class="math inline">\(F\)</span> is an <em>isofibration</em> if for every <span class="math inline">\(a \in \mathcal{A}\)</span> and isomorphism <span class="math inline">\(f : Fa \to b \in \mathcal{B}\)</span>, there is an isomorphism <span class="math inline">\(g: a \to a&#39; \in \mathcal{A}\)</span> such that <span class="math inline">\(Ff = g\)</span>.</p>
</div>
<p>Our main result is the following:</p>
<div class="theorem">
<p>The category <span class="math inline">\(\mathbf{Cat}\)</span> has a model structure on it with:</p>
<ol>
<li><span class="math inline">\(W\)</span> being the class of categorical equivalences;</li>
<li><span class="math inline">\(F\)</span> being the class of isofibrations;</li>
<li><span class="math inline">\(C\)</span> being the class of functors injective on objects.</li>
</ol>
</div>
<p>The rest of this section will be proving the above theorem. That <span class="math inline">\(\mathbf{Cat}\)</span> and <span class="math inline">\(\mathbf{Gpd}\)</span> has all finite limits follows from it having a terminal object, binary products and equalisers. The theory of categories and groupoids are generalised algebraic theories, so the category of models (<span class="math inline">\(\mathbf{Cat}\)</span> and <span class="math inline">\(\mathbf{Gpd}\)</span>, respectively) has all (finite) colimits.</p>
<p>We now break down each of the defining features of a model structure and show that they hold here.</p>
<h2 id="out-of-3">2-out-of-3</h2>
<div class="lemma">
<p>Categorical equivalences are closed under 2-out-of-3.</p>
</div>
<div class="proof">
<p>This follows by basic diagram chasing. If we have the following commuting triangle, with any two maps being equivalences, we can take pseudo-inverses to construct a pseudo-inverse to the third map.</p>
</div>
<h2 id="retracts">Retracts</h2>
<div class="lemma">
<p>The class of categorical equivalences is stable under retracts.</p>
</div>
<div class="proof">
<p>Suppose we have the following commuting diagram where <span class="math inline">\(g\)</span> is an equivalence. We show <span class="math inline">\(f\)</span> is also an equivalence:</p>
<p>Since <span class="math inline">\(g\)</span> is an equivalence, there exists a functor <span class="math inline">\(g&#39;\)</span> such that <span class="math inline">\(gg&#39; \cong 1_V\)</span> and <span class="math inline">\(g&#39;g \cong 1_U\)</span>. The morphism <span class="math inline">\(pg&#39;j\)</span> is then easily seen to be a pseudo-inverse to <span class="math inline">\(f\)</span>, showing that it is also an equivalence.</p>
</div>
<div class="lemma">
<p>The class of isofibrations is stable under retracts.</p>
</div>
<div class="proof">
<p>Suppose the following diagram commutes and <span class="math inline">\(g\)</span> is an isofibration. We need to show that <span class="math inline">\(f\)</span> is an isofibration also:</p>
<p>Let <span class="math inline">\(x \in X\)</span> and <span class="math inline">\(\alpha : fx \to y\)</span> be an isomorphism in <span class="math inline">\(Y\)</span>. We apply <span class="math inline">\(j\)</span> to get an isomorphism <span class="math inline">\(j\alpha : jfx=gix \to jy\)</span>. As <span class="math inline">\(g\)</span> is an isofibration, there is an isomorphism <span class="math inline">\(\beta : ix \to u \in U\)</span> such that <span class="math inline">\(g\beta = j\alpha\)</span>. Applying <span class="math inline">\(p\)</span>, we have an isomorphism <span class="math inline">\(p\beta : pix=x \to pu \in X\)</span>. If we apply <span class="math inline">\(f\)</span> to this map, we have:</p>
<span class="math display">\[\begin{align*}
  fp\beta &amp;= qg\beta &amp;&amp; \text{right square}\\
          &amp;= qj\alpha &amp;&amp; \text{definition of }\beta\\
          &amp;= \alpha.
\end{align*}
\]</span>
<p>Hence, given an isomorphism <span class="math inline">\(\alpha\)</span>, there exists an isomorphism <span class="math inline">\(p\beta\)</span> such that <span class="math inline">\(fp\beta = \alpha\)</span>, so <span class="math inline">\(f\)</span> is also an isofibration.</p>
</div>
<div class="lemma">
<p>The class of functors injective on objects is stable under retracts.</p>
</div>
<div class="proof">
<p>Suppose we have the following diagram in <span class="math inline">\(\mathbf{Cat}\)</span>, where <span class="math inline">\(g\)</span> is a functor injective on objects. We need to show that <span class="math inline">\(f\)</span> is injective on objects also:</p>
<p>Suppose <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> are objects in <span class="math inline">\(X\)</span> such that <span class="math inline">\(fx = fy\)</span>. We have the following chain of equalities:</p>
<span class="math display">\[\begin{align*}
  fx = fy &amp;\implies jfx=jfy\\
          &amp;\implies gix=giy &amp;&amp; \text{(left square)}\\
          &amp;\implies ix=iy &amp;&amp; (g \in C)\\
          &amp;\implies pix=piy\\
          &amp;\implies x=y.
\end{align*}
\]</span>
<p>Hence <span class="math inline">\(f\)</span> is also injective on objects.</p>
</div>
<h2 id="lifting-properties">Lifting properties</h2>
<p>We first give a lemma that will be useful in solving the lifting problems in this section.</p>
<div class="lemma">
<p>Isofibrations that are equivalences are exactly the equivalences that are surjective on objects.</p>
</div>
<div class="proof">
<p>Suppose that <span class="math inline">\(F: \mathcal{A} \to \mathcal{B}\)</span> is an isofibration and an equivalence. To see that it is surjective on objects, let <span class="math inline">\(b \in B\)</span>. As <span class="math inline">\(F\)</span> is an equivalence, it is fully faithful, so there is some <span class="math inline">\(a \in \mathcal{A}\)</span> and isomorphism <span class="math inline">\(\beta : Fa \to b \in \mathcal{B}\)</span>. As <span class="math inline">\(F\)</span> is an isofibration, there is an isomorphism <span class="math inline">\(\alpha : a \to a&#39; \in \mathcal{A}\)</span> such that <span class="math inline">\(F\alpha = \beta\)</span>. Then, we must have that <span class="math inline">\(Fa&#39; = b\)</span>, so <span class="math inline">\(F\)</span> is surjective on objects.</p>
<p>If <span class="math inline">\(F\)</span> is an equivalence that is surjective on objects, it is also an isofibration. Let <span class="math inline">\(a \in \mathcal{A}\)</span> and <span class="math inline">\(\beta : Fa \to b\)</span> be an isomorphism in <span class="math inline">\(\mathcal{B}\)</span>. As <span class="math inline">\(F\)</span> is surjective on objects, <span class="math inline">\(b = Fa&#39;\)</span> for some <span class="math inline">\(a&#39; \in \mathcal{A}\)</span>, so <span class="math inline">\(\beta\)</span> is a map <span class="math inline">\(Fa \to Fa&#39;\)</span>. By <span class="math inline">\(F\)</span> being full, there is a morphism <span class="math inline">\(\alpha : a \to a&#39;\)</span> such that <span class="math inline">\(F\alpha = \beta\)</span>. By <span class="math inline">\(F\)</span> being faithful, this <span class="math inline">\(\alpha\)</span> must be an isomorphism, so <span class="math inline">\(F\)</span> is an isofibration.</p>
</div>
<div class="lemma">
<p>The class of functors injective on objects has the left lifting property with respect to functors that are isofibrations and equivalences.</p>
</div>
<div class="proof">
<p>Suppose we have the following commuting diagram, where <span class="math inline">\(f\)</span> is injective on objects and <span class="math inline">\(g\)</span> is an equivalence and isofibration:</p>
<p>As this commutes, we have the following ``object square’’ commuting in <span class="math inline">\(\mathbf{Set}\)</span>:</p>
<p>In particular, <span class="math inline">\(f_0\)</span> is injective and by Lemma 10, <span class="math inline">\(g_0\)</span> is surjective. As <span class="math inline">\((\text{inj}, \text{surj})\)</span> form a weak factorisation system on <span class="math inline">\(\mathbf{Set}\)</span>, there is a lift <span class="math inline">\(h_0\)</span>. We now aim to turn <span class="math inline">\(h_0\)</span> into a functor. Let <span class="math inline">\(\alpha: y \to y&#39;\)</span> be a morphism in <span class="math inline">\(Y\)</span>. We then have a morphism <span class="math inline">\(j\alpha : jy = gh_0y \to gh_0y&#39;=jy&#39; \in V_0\)</span>. As <span class="math inline">\(g\)</span> is fully faithful, there is a unique morphism <span class="math inline">\(\beta : h_0 y \to h_0 y&#39; \in U\)</span> such that <span class="math inline">\(g\beta = j\alpha\)</span>. We define <span class="math inline">\(h\alpha := \beta\)</span>. As <span class="math inline">\(j\)</span> is a functor, it must preserve identity morphisms and as <span class="math inline">\(g\)</span> is fully faithful, the lift of an identity morphism from <span class="math inline">\(v\)</span> to <span class="math inline">\(u\)</span> must be the identity, so <span class="math inline">\(h\)</span> preserves identity morphisms. Similarly, by functorality of <span class="math inline">\(j\)</span> and fully faithfulness of <span class="math inline">\(g\)</span>, we have that composites are mapped to composites, so <span class="math inline">\(h\)</span> is a functor and makes the bottom triangle commute:</p>
<p>The top triangle commutes on objects, so we need to check it commutes on maps. Given <span class="math inline">\(\alpha : x \to x&#39; \in X\)</span>,</p>
<span class="math display">\[\begin{align*}
  g i \alpha &amp;= j f \alpha\\
             &amp;= g h f \alpha
\end{align*}
\]</span>
<p>So <span class="math inline">\(i \alpha = h f \alpha\)</span> by fully faithfulness of <span class="math inline">\(g\)</span>, meaning that the top triangle commutes. This means that <span class="math inline">\(h\)</span> is indeed a lift, which shows that functors injective on objects are in the left lifting class of fucntors that are equivalences and isofibrations.</p>
</div>
<div class="lemma">
<p>The class of functors injective on objects which are also equivalences has the left lifting property with respect to functors that are isofibrations.</p>
</div>
<div class="proof">
<p>Suppose we have the following diagram commuting, with <span class="math inline">\(f\)</span> an equivalence that is injective on objects and <span class="math inline">\(g\)</span> an isofibration:</p>
<p>To construct a functor <span class="math inline">\(h:Y \to U\)</span>, we use the axiom of choice to get some extra structure. As <span class="math inline">\(f\)</span> is essentially surjective, for every object <span class="math inline">\(y \in Y\)</span>, we choose an isomorphism <span class="math inline">\(\alpha_y : fx_y \to y\)</span>, picking the identity morphism wherever possible, i.e <span class="math inline">\(\alpha_{fx} = 1_{fx}\)</span> (we call the argument of <span class="math inline">\(f\)</span> <span class="math inline">\(x_y\)</span>, which is well defined at <span class="math inline">\(f\)</span> is injective on objects). As <span class="math inline">\(g\)</span> is an isofibration, we choose for every <span class="math inline">\(y \in Y\)</span> a morphism <span class="math inline">\(\beta_y : ix_y \to u_y \in U\)</span> such that <span class="math inline">\(g\beta_y = j\alpha_y\)</span>, again, picking the identity morphism whenever possible, i.e <span class="math inline">\(\beta_{fx} = 1_{ix}\)</span>. On objects, we define <span class="math inline">\(h(y) = u_y\)</span>. For morphisms, the output is a little more complicated. Starting with a map <span class="math inline">\(\gamma : y \to y&#39;\)</span>, we form the composite <span class="math inline">\(\alpha_{y&#39;}^{-1} \gamma \alpha_y : fx_y \to fx_{y&#39;}\)</span>. We let <span class="math inline">\(\overline{\alpha_{y&#39;}^{-1} \gamma \alpha_y} : x_y \to x_{y&#39;}\)</span> be the unique map that <span class="math inline">\(f\)</span> maps to <span class="math inline">\(\alpha_{y&#39;}^{-1} \gamma \alpha_y\)</span>. Then, applying <span class="math inline">\(i\)</span>, we have a map <span class="math inline">\(i \overline{\alpha_{y&#39;}^{-1} \gamma \alpha_y} : ix_y \to ix_{y&#39;}\)</span>. We can then compose with maps <span class="math inline">\(\beta_y^{-1}\)</span> and <span class="math inline">\(\beta_{y&#39;}\)</span> to get <span class="math inline">\(\beta_{y&#39;} i \left(\overline{\alpha_{y&#39;}^{-1} \gamma \alpha_y}\right) \beta_{y}^{-1} : u_y \to u_{y&#39;}\)</span>. This is what we define <span class="math inline">\(h\gamma\)</span> to be.</p>
<p>To see that <span class="math inline">\(h\)</span> is a functor, we see that it sends the identity to the identity:</p>
<span class="math display">\[\begin{align*}
  \beta_{y} i \left(\overline{\alpha_{y}^{-1} 1_y \alpha_y}\right) \beta_{y}^{-1} &amp;= \beta_y i\left( \overline{1_y}\right) \beta_y^{-1} \\
  &amp;= \beta_y i(1_{x_y}) \beta_y^{-1}\\
  &amp;=1_{u_y}.
\end{align*}
\]</span>
<p>We also see that <span class="math inline">\(h\)</span> preserves composites: let <span class="math inline">\(\gamma : y \to y&#39;\)</span> and <span class="math inline">\(\delta : y&#39; \to y&#39;&#39;\)</span>. Then:</p>
<span class="math display">\[\begin{align*}
  \beta_{y&#39;&#39;} i \left(\overline{\alpha_{y&#39;&#39;}^{-1} \delta \alpha_{y&#39;}}\right) \beta_{y&#39;}^{-1} \circ \beta_{y&#39;} i \left(\overline{\alpha_{y&#39;}^{-1}\gamma \alpha_y}\right) \beta_y^{-1} &amp;=  \beta_{y&#39;&#39;} i \left( \overline{\alpha_{y&#39;&#39;}^{-1} \delta \alpha_{y&#39;}}\right) i \left( \overline{\alpha_{y&#39;}^{-1}\gamma \alpha_y}\right) \beta_y^{-1}\\
                                                                                                                                                                                     &amp;= \beta_{y&#39;&#39;}i \left( \overline{\alpha_{y&#39;&#39;}^{-1} \delta \alpha_{y&#39;}} \circ \overline{\alpha_{y&#39;}^{-1} \gamma \alpha_y} \right) \beta_y^{-1}\\
  &amp;= \beta_{y&#39;&#39;} i \left( \alpha^{-1}_{y&#39;&#39;} \delta \gamma \alpha_y \right) \beta_y^{-1}
\end{align*}
\]</span>
<p>We now show that it makes both the triangles commute:</p>
<p>Given <span class="math inline">\(x \in X\)</span>, we need <span class="math inline">\(ix = u_{fx}\)</span>, however this follows from our choice of maps being the identity wherever possible, which means <span class="math inline">\(\beta_{fx} = 1_{ix}\)</span>. Likewise, for maps <span class="math inline">\(\gamma: x \to x&#39;\)</span>, our chosen isomorphisms are the identity, giving <span class="math inline">\(hf\gamma = i\gamma\)</span>. Now, if <span class="math inline">\(y \in Y\)</span>, we see by definition that <span class="math inline">\(gu_y = jy\)</span>, so the bottom triangle commutes on objects. Given a map <span class="math inline">\(\gamma : y \to y&#39; \in Y\)</span>, by the properties of <span class="math inline">\(\beta_y\)</span> we have:</p>
<span class="math display">\[\begin{align*}
  g\left( \beta_{y&#39;} i \left(\overline{\alpha_{y&#39;}^{-1} \gamma \alpha_y}\right) \beta_{y}^{-1} \right) &amp;= g(\beta_{y&#39;}) gi \left(\overline{\alpha_{y&#39;}^{-1} \gamma \alpha_y}\right) g(\beta_{y})^{-1}\\
                                                                                                         &amp;= j(\alpha_{y&#39;}) jf \left( \overline{\alpha_{y&#39;}^{-1} \gamma \alpha_y} \right) j(\alpha_y)^{-1}\\
                                                                                                         &amp;= j(\alpha_{y&#39;}) j(\alpha_{y&#39;})^{-1} j\gamma j(\alpha_y) j(\alpha_y)^{-1}\\
                                                                                                         &amp;=j\gamma
\end{align*}
\]</span>
<p>Hence <span class="math inline">\(h\)</span> is a lift, as required.</p>
</div>
<h2 id="factorisations">Factorisations</h2>
<div class="lemma">
<p>Every functor can be factored as a functor injective on objects, followed by a functor that is an isofibration and equivalence.</p>
</div>
<div class="proof">
<p>Given <span class="math inline">\(f:X \to Y\)</span>, we form a new category <span class="math inline">\(Z\)</span> with objects given by <span class="math inline">\(X_0 \coprod Y_0\)</span>. We define the hom-sets as follows:</p>
<span class="math display">\[\begin{align*}
  Z(x,y) := \begin{cases}
    x \in X, y \in X &amp;\implies Y(fx, fy),\\
    x \in X, y \in Y &amp;\implies Y(fx, y),\\
    x \in Y, y \in X &amp;\implies Y(x, fy),\\
    x \in Y, y \in Y &amp;\implies Y(x, y).
  \end{cases}
\end{align*}
\]</span>
<p>We then have a functor <span class="math inline">\(X \to Z\)</span> which is the identity on objects, and <span class="math inline">\(f\)</span> on maps, which, in particular, is injective on objects. We can also construct another functor <span class="math inline">\(Z \to Y\)</span> which is formed by applying <span class="math inline">\(f\)</span> to objects from <span class="math inline">\(X\)</span> and the identity to objects from <span class="math inline">\(y\)</span>. It is then the identity morphism on maps, which means it is fully faithful. It is also surjective on objects as every object in <span class="math inline">\(Y\)</span> is mapped to itself by this functor. The composite of these two morphisms is <span class="math inline">\(f\)</span> on objects and <span class="math inline">\(f\)</span> on maps, hence it is a factorisation of <span class="math inline">\(f\)</span> into a functor injective on objects, followed by a surjective equivalence (which by Lemma 10) is an equivalence and isofibration), as required.</p>
</div>
<div class="lemma">
<p>Every functor can be factored as a functor injective on objects and an equivalence, followed by an isofibration.</p>
</div>
<div class="proof">
<p>Given <span class="math inline">\(f:X \to Y\)</span> we form the comma category <span class="math inline">\(F \downarrow 1_Y\)</span>, then take the full subcategory spanned by objects <span class="math inline">\((x, y, \phi : fx \to y)\)</span> where <span class="math inline">\(\phi\)</span> is an isomorphism in <span class="math inline">\(Y\)</span>. Denote this category as <span class="math inline">\(F \downarrow_{\cong} 1_Y\)</span>
Note that we have a functor <span class="math inline">\(X \to F \downarrow_{\cong} 1_Y\)</span> defined by sending <span class="math inline">\(x \mapsto (x , fx, 1_{fx})\)</span> and <span class="math inline">\(\alpha : x \to x&#39; \mapsto (\alpha, f\alpha)\)</span>. This is clearly injective on objects and fully faithful. We also have that every <span class="math inline">\((x, y, \phi) \cong (x, fx, 1_{fx})\)</span> by the following commuting square in <span class="math inline">\(Y\)</span> (with horizontal maps being isomorphisms):</p>
<p>We have a functor <span class="math inline">\(f \downarrow_{\cong} 1_Y \to Y\)</span> given by projecting out the second component. This functor is also seen to be an isofibration: given <span class="math inline">\((x, y, \phi)\)</span> and an isomorphism <span class="math inline">\(\alpha : y \to y&#39; \in Y\)</span>, the following square commutes, with horizontal maps isomorphisms, so is an isomorphism in <span class="math inline">\(f \downarrow_{\cong} 1_Y\)</span>:</p>
<p>Our projection functor sends this isomorphism to <span class="math inline">\(\alpha\)</span>, so it is an isofibration. The composite of the two functors defined is easily seen to be equal to <span class="math inline">\(f\)</span>, completing the factorisation of <span class="math inline">\(f\)</span> as an equivalence that is injective on objects, followed by an isofibration.</p>
</div>
<h1 id="putting-it-all-together">Putting it all together</h1>
<div class="corollary">
<p>Functors injective on objects and equivalences that are isofibrations, form a weak factorisation system on <span class="math inline">\(\mathbf{Cat}\)</span>.</p>
</div>
<div class="proof">
<p>Lemma 9 shows functors injective on objects are stable under retracts. Lemmas 9 and 9 show that equivalences that are isofibrations are also stable under retracts. Lemma 13 gives the desired lifting data and Lemma 14 gives the desired factorisation.</p>
</div>
<div class="corollary">
<p>Equivalences that are injective on objects and isofibrations form a weak factorisation system on <span class="math inline">\(\mathbf{Cat}\)</span>.</p>
</div>
<div class="proof">
<p>Lemmas 7 and 9 show that the class of equivalences that are injective on objects is stable under retracts. Lemma 8 shows the class of isofibrations are stable under retracts. Lemma 12 gives the desired lifting data and Lemma 14 gives the desired factorisation.</p>
</div>
<div class="corollary">
<p>The category <span class="math inline">\(\mathbf{Cat}\)</span> has a model structure on it with:</p>
<ol>
<li><span class="math inline">\(W\)</span> being the class of equivalences;</li>
<li><span class="math inline">\(F\)</span> being the class of isofibrations;</li>
<li><span class="math inline">\(C\)</span> being the class of functors injective on objects.</li>
</ol>
</div>
<div class="proof">
<p>Lemma shows that <span class="math inline">\(W\)</span> satisfies 2-out-of-3. Corollaries 15 and 16 show that <span class="math inline">\((C \cap W, F)\)</span> and <span class="math inline">\((C, F \cap W)\)</span> are weak factorisation systems.</p>
</div>
<p>This proves Theorem 5. To see that this restricts to <span class="math inline">\(\mathbf{Gpd}\)</span> we only need to realise that if <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> are groupoids, the categories constructed in the Factorisations section are also groupoids. This means we have the following:</p>
<div class="corollary">
<p>The category <span class="math inline">\(\mathbf{Gpd}\)</span> has a model structure on it with:</p>
<ol>
<li><span class="math inline">\(W\)</span> being the class of categorical equivalences;</li>
<li><span class="math inline">\(F\)</span> being the class of isofibrations;</li>
<li><span class="math inline">\(C\)</span> being the class of functors injective on objects.</li>
</ol>
</div>
</section>
<hr>
<script src="https://giscus.app/client.js"
        data-repo="jeslie0/jeslie0.github.io"
        data-repo-id="R_kgDOG3FkcQ"
        data-category="Announcements"
        data-category-id="DIC_kwDOG3Fkcc4CPMWW"
        data-mapping="title"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="light"
        data-lang="en"
        data-loading="lazy"
        crossorigin="anonymous"
        async>
</script>

</article>
]]></description>
    <pubDate>Sat, 06 Mar 2021 00:00:00 UT</pubDate>
    <guid>https://jeslie0.github.com/blog/2021-03-06-Canonical-Model-Structure-on-Cat.html</guid>
    <dc:creator>James Leslie</dc:creator>
</item>
<item>
    <title>iPad Screen Sharing to Zoom on a University Network</title>
    <link>https://jeslie0.github.com/blog/2021-03-05-Zoom-screen-sharing.html</link>
    <description><![CDATA[<head>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <link rel="stylesheet" href="/css/theorem.css" />
</head>
<section class="header">
  Posted on March  5, 2021
  
  by James Leslie
  
</section>
<section>
  <p>I am currently a teaching assistant for a first year linear algebra course. We recently made the switch to a hybrid setup, meaning that I am streaming the tutorials on Zoom as well as talking to a class in-person. Instead of writing on the physical whiteboards in the classroom, I instead write on my iPad and share the screen through Zoom. Previously, when the tutorials were just based on Zoom, this setup worked pretty well - I can share my screen over Zoom using my home WiFi network. However, I can’t screen share over the university network due to the way it is set up.</p>
<h1 id="solution-1">Solution 1</h1>
<p>The basic solution is to log into the Zoom call on the iPad, and share the screen through the Zoom app. This is less than ideal, however; as it means that if you haven’t turned off notifications, they can be displayed to the class. Also, I use the app GoodNotes to write my solutions on. The app is good, but there is a large header of different pen options that takes up too much space for my liking. This header is not shown when sharing content to Zoom over the network, rather than through the IPad.</p>
<h1 id="solution-2">Solution 2</h1>
<p>The current solution I use works on Windows 10 laptops. Windows 10 has the functionality to be connected to a network whilst also being a WiFi hotspot. Information on how to enable this can be found <a href="https://support.microsoft.com/en-us/windows/use-your-pc-as-a-mobile-hotspot-c89b0fad-72d5-41e8-f7ea-406ad9036b85">here</a>. Once the hotspot is up and running, we can connect the iPad to the network. Then, Zoom can detect the IPad, and we can share content over this network. So far, this has worked well for me. The only caveat is that it seems like you can’t get access to the internet on the IPad whilst connected to the network. This isn’t a major problem for me, as I still have access through my laptop.</p>
<p>This setup might work for other operating systems, but I am not able to test that theory out.</p>
</section>
<hr>
<script src="https://giscus.app/client.js"
        data-repo="jeslie0/jeslie0.github.io"
        data-repo-id="R_kgDOG3FkcQ"
        data-category="Announcements"
        data-category-id="DIC_kwDOG3Fkcc4CPMWW"
        data-mapping="title"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="light"
        data-lang="en"
        data-loading="lazy"
        crossorigin="anonymous"
        async>
</script>

</article>
]]></description>
    <pubDate>Fri, 05 Mar 2021 00:00:00 UT</pubDate>
    <guid>https://jeslie0.github.com/blog/2021-03-05-Zoom-screen-sharing.html</guid>
    <dc:creator>James Leslie</dc:creator>
</item>
<item>
    <title>Is zero a natural number?</title>
    <link>https://jeslie0.github.com/blog/2019-04-15-is-zero-a-natural-number.html</link>
    <description><![CDATA[<head>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <link rel="stylesheet" href="/css/theorem.css" />
</head>
<section class="header">
  Posted on April 15, 2019
  
  by James Leslie
  
</section>
<section>
  <p>I help tutor an introductory course on pure mathematics at Edinburgh University. One my responsibilities is to help answer questions that the students have in person and online on Piazza; a Q&amp;A forum used by the class. The other day, a student created a poll asking whether or not zero is a natural number. I have found that this question usually always splits the audience, with a majority usually favouring “no” as the correct answer. I remember the first time I came across this debate was during my final year of high school, when our teacher described the “home of zero” as a controversial topic. At that time, for no legitimate reason, I chose to believe that it should be a natural number and this choice has more or less stuck with me till this day. Being a student of pure mathematics, it does strike me as an odd that this causes such a debate. Having the natural numbers with or without zero doesn’t affect mathematics in the slightest; we can simply define a new set to be the naturals with or without zero.</p>
<p>When debating against zero being natural, more often than not, one will make some form of an appeal to tradition. Usually, it goes something like: “people thought up and used other natural numbers before coming up with the concept of zero, so it is not natural”. I personally don’t think this is a good argument as we don’t follow conventions from the past blindly; they can be updated and changed if necessary. A better (and also common) argument is that the naturals are used for counting. By starting our counting system at 1, the set <span class="math inline">\( \{1, 2, \ldots, n \}\)</span> contains exactly <span class="math inline">\( n\)</span> elements, while if treat <span class="math inline">\( 0\)</span> as the start, then the set of elements up to <span class="math inline">\( n\)</span> will have cardinality <span class="math inline">\( n+1\)</span>. If you have <span class="math inline">\( n\)</span> objects, it seems more natural to put them in a bijection in the following way, your first object is identified with <span class="math inline">\( 1\)</span>, your second with <span class="math inline">\( 2\)</span> and so on. This idea comes from treating the naturals just as an ordered set. There is no need for something to come before the object that we call <em>first</em>, and if there was, our language would arguably be nefarious.</p>
<p>I think the most compelling argument for including zero in the natural numbers is from how the naturals are constructed through Peano’s axioms. Simply, one starts with <span class="math inline">\( 0\)</span> and applies a successor operation, <span class="math inline">\( S\)</span> to it. This gives a new term <span class="math inline">\( S0\)</span> which we treat as being distinct from <span class="math inline">\( 0\)</span>, by some of Peano’s other axioms. We then define <span class="math inline">\( 1:= S0\)</span>, and in general define <span class="math inline">\( n:= S(n-1)\)</span>. Peano’s axioms; however, don’t construct a set, per se, but a <em>Peano Structure</em>. By saying this is not a set, I mean in the same sense that a group is not a set, but a set with structure, not that it forms a proper class. There are many different Peano structures, but the naturals with <span class="math inline">\( 0\)</span> and the usual successor function, <span class="math inline">\( - + 1\)</span> satisfy a nice universal property. We can define a category whose objects are (set based) Peano structures, that is, triples <span class="math inline">\( (X, S:X \rightarrow X, a \in X)\)</span> and whose maps <span class="math inline">\( f: (X, S, a) \rightarrow (Y, S&#39;, b)\)</span> are functions <span class="math inline">\( f:X \rightarrow Y\)</span> that make the following commute:</p>
<p><span class="math display">\[\begin{tikzcd} 1 \ar[r, &quot;a&quot;] \ar[rd, &quot;b&quot;&#39;] &amp; X \ar[r, &quot;S&quot;] \ar[d, &quot;f&quot;] &amp; X \ar[d, &quot;f&quot;] \\
 &amp; Y \ar[r, &quot;S&#39;&quot;&#39;] &amp; Y\end{tikzcd}\]</span></p>
<p>The universal property satisfied by <span class="math inline">\( (\mathbb{N}, S, 0)\)</span> is that it is initial in this category, that is, given any other object <span class="math inline">\( (Y, S&#39;, b \in Y)\)</span>, there is a unique map <span class="math inline">\( f: (\mathbb{N}, S, 0) \rightarrow (Y, S&#39;, b )\)</span>. This effectively is what lets us define functions recursively. From a category theory perspective, <span class="math inline">\( 0:1 \rightarrow \mathbb{N}\)</span> is a generalised element of <span class="math inline">\( \mathbb{N}\)</span>. However, we could equally define an isomorphic copy of our initial Peano structure by swapping some symbols around and renaming our generalised element “0” as “1”. Then, applying the obvious forgetful functor we can get something that looks like a natural number object, but starts at 1. This leads me to a critique of most arguments about the naturality of zero: mostly the argument revolves around what it means to be a natural number, when really it should be based on what it means to be <em>zero.</em></p>
<p>When speaking in terms of sets, the only difference between the naturals with or without zero, is what we call the elements. As a set, the element <span class="math inline">\( 0 \in \mathbb{N}\)</span> can be interpreted to be any element we want, precisely because there is no structure on a set. If we were feeling perverse, we could say that <span class="math inline">\( 0+1 = 7\)</span>, simply by interpreting the symbols differently. It is when we add certain structure that the notion of zero becomes necessary. If we are needing an additive identity then the natural numbers begin to resemble a monoid and hence should be taken to include a zero. Are we simply counting objects or treating the naturals as an ordered set? Then there is no need for the additive identity, so the first element should probably be <span class="math inline">\( 1\)</span>.</p>
<p>So is zero a natural number? In my opinion, that depends on the problem you are working on. I think the reason that most people say that zero is not part of the naturals, is due to them thinking of the naturals as being an ordered set. This concept is taught much earlier in people’s lives than the idea of a monoid, or just the notion of an identity. This debate won’t be over any time soon, but hopefully people can start understanding the other side of the debate and see that both notions of the natural numbers make sense in their given context.</p>
</section>
<hr>
<script src="https://giscus.app/client.js"
        data-repo="jeslie0/jeslie0.github.io"
        data-repo-id="R_kgDOG3FkcQ"
        data-category="Announcements"
        data-category-id="DIC_kwDOG3Fkcc4CPMWW"
        data-mapping="title"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="light"
        data-lang="en"
        data-loading="lazy"
        crossorigin="anonymous"
        async>
</script>

</article>
]]></description>
    <pubDate>Mon, 15 Apr 2019 00:00:00 UT</pubDate>
    <guid>https://jeslie0.github.com/blog/2019-04-15-is-zero-a-natural-number.html</guid>
    <dc:creator>James Leslie</dc:creator>
</item>
<item>
    <title>A group object in the category of groups</title>
    <link>https://jeslie0.github.com/blog/2019-01-12-A-group-object-in-the-category-of-groups.html</link>
    <description><![CDATA[<head>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <link rel="stylesheet" href="/css/theorem.css" />
</head>
<section class="header">
  Posted on January 12, 2019
  
  by James Leslie
  
</section>
<section>
  <p>I think most people are surprised when they first discover what a group object in the category of groups is; I know I certainly was! I won’t spoil what it is for you just now, but we will discuss it and why it is what it is later on in this post, so if you want to figure it out for yourself - read no further!</p>
<p>First, I should talk about what a “- object” actually is. One of the themes of category theory is to take set based structures (monoids, rings, vector spaces, topological spaces etc) and lift them to arbitrary categories. This is done more or less by the word ‘set’ with the word ‘object’ and the word ‘function’ with the word ‘morphism’. Lets look at a relevant example.</p>
<p>A group object in a category <span class="math inline">\(\mathcal{C}\)</span> with finite products, is an object G with morphisms <span class="math inline">\(\mu :G \times G \rightarrow G\)</span>, <span class="math inline">\(e: 1 \rightarrow G\)</span> and <span class="math inline">\(\text{inv}:G \rightarrow G\)</span>, such that</p>
<ol>
<li><span class="math inline">\(\mu(\mu \times 1_G) = \mu(1_G \times \mu)\)</span>,</li>
<li><span class="math inline">\(\mu(e \times 1_G) = \pi_{G,1}^1\)</span> and <span class="math inline">\(\mu(1_G \times e) = \pi_{1,G}^2\)</span></li>
<li><span class="math inline">\(\mu(\text{inv} \times 1_G) \Delta = \mu(1_G \times \text{inv}) \Delta =e_G\)</span>, where <span class="math inline">\(e_G\)</span> is the unique map <span class="math inline">\(G \rightarrow 1\)</span> composed with <span class="math inline">\(e\)</span>, and <span class="math inline">\(\Delta\)</span> is the diagonal map.</li>
</ol>
<p>Here, 1 is the terminal object (the 0-product) in <span class="math inline">\(\mathcal{C}\)</span>.</p>
<p>This definition is set up so that an ordinary group is simply just a group object in the category of sets. This allows us to easily define group objects in other categories, for example, a topological group is just a group object in the category of topological spaces. One key part of the definition is that the morphims of a group object must be in the category we are working over.</p>
<p>Now before we figure out what a group object the category of groups is, it will be helpful to go off on a slight tangent and answer a different question: when is a group’s operation a group homomorphism? It is the case that the metric on a metric space is always continuous, but does it generalise? Let’s take a look.</p>
<p>Considering a group <span class="math inline">\(G\)</span>, we shall write it’s operation simply as concatenation (or <span class="math inline">\(\times_G\)</span>) and when regarding it as a function, we shall call it <span class="math inline">\(f:G \times G \rightarrow G\)</span>. The following then holds for all <span class="math inline">\(a,b,c \in G\)</span>:</p>
<span class="math display">\[\begin{align*}
f : G \times G \to G \text{ is a group hom} &amp;\LongLeftRightarrow f((a,b) \times_{G\timesG} (c,d))= f(a,b) \times_G f(c,d)\\
&amp;\LongLeftRightarrow f(ac, bd) = ab \times_G cd\\
&amp;\LongLeftRightarrow acbd=abcd\\
&amp;\LongLeftRightarrow cb=bc
\end{align*}
\]</span>
<p>Therefore the group operation is a homomorphim if and only if the group is abelian! A surprise to be sure, but a welcome one. Now, how does this help us with our question? If there is a group homormorphism from <span class="math inline">\(G \times G \rightarrow G\)</span> that satisfies the above properties, it must be the group operation on <span class="math inline">\(G\)</span>, by the following quick calculation:</p>
<span class="math display">\[\begin{align*}
f(g,h) &amp;= f((g,e) \times_{G \times G} (e,h)) &amp;&amp;\\
&amp;= f(g,e)f(e,h) &amp;&amp; f \text{ is homomorphism,}\\
&amp;=g \times_G h &amp;&amp; f \text{ satisfies 2.}\\
&amp;gh&amp;&amp;
\end{align*}
\]</span>
<p>However, we know that the group operation is a group homomorphim if and only the group is abelian! This then means that a group object in the category of groups is precisely an abelian group! This certainly seemed strange to me when I first saw the result. It does have uses though, for an example, if you want to show that some group is abelian, all you need to do is show it is a group object. This method can be implemented to show that the second fundamental group is abelian, which is done on page xix of Leinster’s <a href="https://arxiv.org/abs/math/0305049">Higher Operads, Higher Categories</a>.</p>
<p>This does raise other questions of a similar nature - what is a ring object in the category of rings for example? It is quick to see that such a ring <span class="math inline">\(R\)</span> needs to be the trivial ring. We observe that the additive and multiplicative identities come from maps <span class="math inline">\(0_R, 1_R : 1 \rightarrow R\)</span>, that is they are encoded as maps from the terminal object to <span class="math inline">\(R\)</span>. In the category of rings, however, the terminal object is also the initial object. This forces <span class="math inline">\(1_R = 0_R\)</span>, hence <span class="math inline">\(R\)</span> must be trivial.</p>
</section>
<hr>
<script src="https://giscus.app/client.js"
        data-repo="jeslie0/jeslie0.github.io"
        data-repo-id="R_kgDOG3FkcQ"
        data-category="Announcements"
        data-category-id="DIC_kwDOG3Fkcc4CPMWW"
        data-mapping="title"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="light"
        data-lang="en"
        data-loading="lazy"
        crossorigin="anonymous"
        async>
</script>

</article>
]]></description>
    <pubDate>Sat, 12 Jan 2019 00:00:00 UT</pubDate>
    <guid>https://jeslie0.github.com/blog/2019-01-12-A-group-object-in-the-category-of-groups.html</guid>
    <dc:creator>James Leslie</dc:creator>
</item>
<item>
    <title>Why isn't every category isomorphic to its opposite?</title>
    <link>https://jeslie0.github.com/blog/2018-07-07-Why-isn%27t-every-category-isomorphic-to-its-opposite.html</link>
    <description><![CDATA[<head>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <link rel="stylesheet" href="/css/theorem.css" />
</head>
<section class="header">
  Posted on July  7, 2018
  
  by James Leslie
  
</section>
<section>
  <p>Whenever one comes across a mathematical object, such as a group, topological space etc, it is important to look at how it interacts with other similar objects. The same goes for categories with functors being how they interact.</p>
<div class="definition">
<p>Given two categories <span class="math inline">\( \mathscr{A}, \mathscr{B}\)</span>, a (covariant) functor <span class="math inline">\( F\)</span> from <span class="math inline">\( \mathscr{A}\)</span> to <span class="math inline">\( \mathscr{B}\)</span> assigns to each object <span class="math inline">\( A \in \mathscr{A}\)</span> an object <span class="math inline">\( F(A) \in \mathscr{B}\)</span> and to each <span class="math inline">\( \mathscr{A}\)</span>-morphism <span class="math inline">\( f:A \rightarrow A&#39;\)</span>, a <span class="math inline">\( \mathscr{B}\)</span>-morphism <span class="math inline">\( F(f):F(A) \rightarrow F(A&#39;)\)</span>. The assignements must respect composition and identities, so</p>
<ul>
<li><span class="math inline">\( F(g \circ h) = F(g) \circ F(h)\)</span>, for <span class="math inline">\( \mathscr{A}\)</span>-maps <span class="math inline">\( f,g\)</span>,</li>
<li><span class="math inline">\( F(1_A) = 1_{F(A)}\)</span>, for all <span class="math inline">\( A \in \mathscr{A}\)</span>.</li>
</ul>
</div>
<p>We write functors as <span class="math inline">\( F: \mathscr{A} \rightarrow \mathscr{B}\)</span>. This then leads to the category <span class="math inline">\( \mathbf{CAT}\)</span> whose objects are categories and whose morphisms are functors. We say that two categories are isomorphic if they are isomorphic in <span class="math inline">\( \mathbf{CAT}\)</span>. Given a category <span class="math inline">\( \mathscr{A}\)</span>, we can form its opposite category <span class="math inline">\( \mathscr{A}^{op}\)</span>, whose objects are the same as those in <span class="math inline">\( \mathscr{A}\)</span>, with <span class="math inline">\( \mathscr{A}^{op}\)</span>-morphisms <span class="math inline">\( f:A&#39; \rightarrow A\)</span> in one to one correspondence with <span class="math inline">\( \mathscr{A}\)</span>-morphisms <span class="math inline">\( f:A \rightarrow A&#39;\)</span>. This means we can think of <span class="math inline">\( \mathscr{A}^{op}\)</span> as being <span class="math inline">\( \mathscr{A}\)</span> with it’s morphisms turned around. It is clear from the definition of a functor that the obvious correspondence between a category and its opposite is not a functor. However, we can define a new type of functor that makes this possible.</p>
<div class="definition">
<p>A contravariant functor <span class="math inline">\( F\)</span> from <span class="math inline">\( \mathscr{A}\)</span> to <span class="math inline">\( \mathscr{B}\)</span> is a (covariant) functor <span class="math inline">\( F:\mathscr{A}^{op} \rightarrow \mathscr{B}\)</span>.</p>
</div>
<p>The key property of a contravariant functor is that it reverses composition. If <span class="math inline">\( F\)</span> from <span class="math inline">\( \mathscr{A}\)</span> to <span class="math inline">\( \mathscr{B}\)</span> is a contravariant functor, then for <span class="math inline">\( \mathscr{A}\)</span>-morphisms <span class="math inline">\( f, g\)</span>, we have <span class="math inline">\( F(f \circ g) = F(g) \circ F(f)\)</span>.</p>
<p>A question one may ask is whether or not a category is isomorphic to its opposite. In general this is false; however, to newcomers this isn’t always obvious why. A typical false proof goes along the following lines:</p>
<ol>
<li>For any category <span class="math inline">\( \mathscr{A}\)</span>, there are canonical contravariant functors <span class="math inline">\( F:\mathscr{A}^{op} \rightarrow \mathscr{A}\)</span> and <span class="math inline">\( G:\mathscr{A} \rightarrow \mathscr{A}^{op}\)</span>.</li>
<li>Clearly <span class="math inline">\( F\circ G= 1_{\mathscr{A}}\)</span> and <span class="math inline">\( G\circ F= 1_{\mathscr{A}^{op}}\)</span>.</li>
<li><span class="math inline">\( \mathscr{A} \cong \mathscr{A}^{op}\)</span>.</li>
</ol>
<p>The reason this doesn’t hold is because the functors defined are contravariant, not covariant. To show such an isomorphism exists, one would need to construct a covariant functor <span class="math inline">\( F:\mathscr{A}^{op} \rightarrow \mathscr{A}\)</span>, so in particular the composition rule in Definition 1 must hold. Clearly for an arbitrary category, the canonical (contravariant) functor breaks this rule. A counter-example is to have a category with a terminal object and but no initial object. Its opposite has an initial object but no terminal, hence the two aren’t isomorphic.</p>
<div class="ex">
<p>Take the following two categories <span class="math inline">\(\mathcal A\)</span> and <span class="math inline">\(\mathcal B\)</span>, where <span class="math inline">\(\mathcal B = \mathcal A ^{\text{op}}\)</span>.</p>
<p><img src="./Images/untitled.png" /></p>
<p>Suppose we have a covariant functor from <span class="math inline">\(\mathcal A \rightarrow \mathcal B\)</span> that fixes the objects. The issue is that there are no arrows in <span class="math inline">\(\mathcal B\)</span> that we can map <span class="math inline">\(f\)</span> or <span class="math inline">\(g\)</span> to. Since such a functor doesn’t exist, <span class="math inline">\(\mathcal A\)</span> and <span class="math inline">\(\mathcal B\)</span> cannot be isomorphic. For such a functor to exist, it must be contravariant.</p>
</div>
</section>
<hr>
<script src="https://giscus.app/client.js"
        data-repo="jeslie0/jeslie0.github.io"
        data-repo-id="R_kgDOG3FkcQ"
        data-category="Announcements"
        data-category-id="DIC_kwDOG3Fkcc4CPMWW"
        data-mapping="title"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="light"
        data-lang="en"
        data-loading="lazy"
        crossorigin="anonymous"
        async>
</script>

</article>
]]></description>
    <pubDate>Sat, 07 Jul 2018 00:00:00 UT</pubDate>
    <guid>https://jeslie0.github.com/blog/2018-07-07-Why-isn%27t-every-category-isomorphic-to-its-opposite.html</guid>
    <dc:creator>James Leslie</dc:creator>
</item>
<item>
    <title>Categories of elements</title>
    <link>https://jeslie0.github.com/blog/2018-06-30-Categories-of-elements.html</link>
    <description><![CDATA[<head>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <link rel="stylesheet" href="/css/theorem.css" />
</head>
<section class="header">
  Posted on June 30, 2018
  
  by James Leslie
  
</section>
<section>
  <p>When learning about colimits and presheaf categories, one often meets a category of elements. The definition of the category isn’t particularly hard to understand or remember; however, I didn’t immediately have an intuition for why it is useful or where the definition came from. This has lead me to play with it and try to understand some properties of it.</p>
<div class="definition">
<p>Given a locally small category <span class="math inline">\( \mathbb{A}\)</span> and a functor <span class="math inline">\( X:\mathbb{A}^{op} \rightarrow \mathbf{Set}\)</span>, the category of elements of <span class="math inline">\( X\)</span>, denoted <span class="math inline">\( \mathbb{E}(X)\)</span> or <span class="math inline">\( \int^\mathbb{A} X\)</span>, is defined as follows:</p>
<ul>
<li>Objects are pairs <span class="math inline">\( (A \in \mathbb{A}, x \in X(A))\)</span>,</li>
<li>Morphisms <span class="math inline">\( f:(A, x) \rightarrow (A&#39;,x&#39;)\)</span> are maps <span class="math inline">\( f:A \rightarrow A&#39; \in \mathbb{A}\)</span> such that <span class="math inline">\( (Xf)(x&#39;)=x\)</span>.</li>
</ul>
</div>
<p>Every category of elements has a projection functor <span class="math inline">\( P:\mathbb{E}(x) \rightarrow \mathbb{A}\)</span> associated with it that sends <span class="math inline">\( (A,x) \mapsto A\)</span> and <span class="math inline">\( f \mapsto f\)</span>. There is a useful property tucked away in the definition: for any <span class="math inline">\( \mathbb{A}\)</span>-arrow <span class="math inline">\( f:A&#39; \rightarrow A\)</span>, there is a unique element <span class="math inline">\( x&#39; \in X(A&#39;)\)</span> such that there is an <span class="math inline">\( \mathbb{E}(X)\)</span>-morphism <span class="math inline">\( f:(A&#39;,x&#39;) \rightarrow (A, x)\)</span>, namely <span class="math inline">\( x&#39; = (Xf)(x)\)</span>. As a result of this, we will often write morphism as <span class="math inline">\( f:(A&#39;, (Xf)(x)) \rightarrow (A,x)\)</span>. Another observation is that we can write <span class="math inline">\( \mathbb{E}(X)\)</span> as a comma category.</p>
<div class="lemma">
<p>There is an isomorphism <span class="math inline">\( \mathbb{E}(X) \cong (1 \Rightarrow X)\)</span>.</p>
</div>
<div class="proof">
<p>We look at the comma category for the following diagram:</p>
<p><img src="./Images/2018/06/comma.png" /></p>
<p>The double stroke 1 is the terminal category and the functor  1 is the functor that selects the terminal set. This category has as objects, pairs <span class="math inline">\( (A \in \mathbb{A}, x:1 \rightarrow X(A))\)</span> and morphisms <span class="math inline">\( f:(A,x) \rightarrow (A&#39;,x&#39;)\)</span> are commuting triangles:</p>
<p><img src="./Images/2018/06/comma11.png" /></p>
<p>That this triangle commutes is the same as stating <span class="math inline">\( x = (Xf)(x&#39;)\)</span>, which is the condition above.</p>
</div>
<p>We can use the category of elements to relate representablity to the existence of a terminal object.</p>
<div class="proposition">
<p>[1, Exercise 6.2.23] Let <span class="math inline">\( X\)</span> be a presheaf on a locally small category. <span class="math inline">\( X\)</span> is representable if and only if <span class="math inline">\( \mathbb{E}(X)\)</span> has a terminal object.</p>
</div>
<div class="proof">
<p>The category <span class="math inline">\( \mathbb{E}(X)\)</span> has a terminal object if and only if there is an object <span class="math inline">\( (A, x)\)</span> such that for any <span class="math inline">\( (A&#39;,x&#39;)\)</span>, there is exactly one morphism <span class="math inline">\( f:(A&#39;,x&#39;) \rightarrow (A,x)\)</span>. This is equivalent to there being an <span class="math inline">\( A \in \mathbb{A}\)</span> and <span class="math inline">\( x \in X(A)\)</span> such that for all <span class="math inline">\( A&#39; \in \mathbb{A}\)</span>, <span class="math inline">\( x \in X(A&#39;)\)</span>, there is a unique morphism <span class="math inline">\( f:A&#39; \rightarrow A\)</span> such that <span class="math inline">\( (Xf)(x) = x&#39;\)</span>. This condition is equivalent to <span class="math inline">\( X\)</span> being representable, by [Corollary 4.3.2, 1].</p>
</div>
<p>One of the most important uses of the category of elements is to show that any presheaf is a colimit of a certain diagram, in a canonical way. This is the main purpose of the category of elements in [1, Definition 6.2.16].</p>
<div class="proposition">
<p>[1, Theorem 6.2.17] *Let <span class="math inline">\( \mathbb{A}\)</span> be small and <span class="math inline">\( X:\mathbb{A}^{op} \rightarrow \mathbf{Set}\)</span> a presheaf. Then <span class="math inline">\( X\)</span> is the colimit of the following diagram:</p>
<p><img src="./Images/2018/06/diagram.png" /></p>
<p>That is, <span class="math inline">\( X \cong \lim{\rightarrow \mathbb{E}(X)}(H\bullet \circ P)\)</span>.</p>
</div>
<div class="proof">
<p>We should first note that this does make sense; as <span class="math inline">\( \mathbb{A}\)</span> is small, so is <span class="math inline">\( \mathbb{E}(X)\)</span>, hence a colimit does indeed exist.</p>
<p>We know that presheaf categories have all (small) limits and colimits, so a colimit of <span class="math inline">\( H_\bullet \circ P\)</span> exists. Let <span class="math inline">\( Y \in [\mathbb{A}^{op}, \mathbf{Set}]\)</span> be a presheaf and let <span class="math inline">\( (\alpha_{(A,x)}:(H_\bullet \circ P)(A,x) \rightarrow Y)_{(A,x)\in \mathbb{E}(X)}\)</span> be a cocone on <span class="math inline">\( H_\bullet \circ P\)</span> with vertex <span class="math inline">\( Y\)</span>. We can simply this to have <span class="math inline">\( (\alpha_{(A,x)}:(H_A \rightarrow Y)_{(A,x)\in \mathbb{E}(X)}\)</span>. This is a family of natural transformations, so for all <span class="math inline">\( f:(A&#39;,x&#39;) \rightarrow (A, x)\)</span> in <span class="math inline">\( \mathbb{E}(X)\)</span>, the folowing diagram commutes</p>
<p><img src="./Images/2018/06/img1.png" /></p>
<p>By the Yoneda lemma, every natural transformation <span class="math inline">\( \alpha_{(A,x)}:H_A \rightarrow Y\)</span> corresponds to a unique element <span class="math inline">\( (\alpha_{(A,x)})_A(1_A) \in Y(A)\)</span>, which we shall denote <span class="math inline">\( y_{(A,x)}\)</span>. As the diagram above commutes, it commutes for all <span class="math inline">\( A \in \mathbb{A}\)</span>, so in particular it commutes for <span class="math inline">\( A&#39;\)</span>. This gives us the following:</p>
<p><img src="./Images/2018/06/img2.png" /></p>
<p>This gives us <span class="math inline">\( y_{(A&#39;,(Xf)(x))} = (\alpha_{(A,x)})_{A&#39;}(f)\)</span>. As <span class="math inline">\( \alpha_{(A,x)}\)</span> is a natural transformation, the following square commutes:</p>
<p><img src="./Images/2018/06/img3.png" /></p>
<p>This gives us <span class="math inline">\( (Yf)(y_{(A,x)}) = (\alpha_{(A,x)})_{A&#39;}(f)\)</span>. Combining this with the above we see that a cocone on <span class="math inline">\( Y\)</span> is a collection of elements <span class="math inline">\( (y_{(A,x)})_{(A,x)\in \mathbb{E}(X)}\)</span> such that for any <span class="math inline">\( f:(A&#39;,(Xf)(x)) \rightarrow (A,x)\)</span> in <span class="math inline">\( \mathbb{E}(X)\)</span>, <span class="math inline">\( (Yf)(y_{(A,x)}) = y_{(A&#39;, (Xf)(x))}\)</span>.</p>
<p>An equivalent way to write <span class="math inline">\( y_{(A,x)}\)</span> is <span class="math inline">\( \overline{\alpha}_A(x):X(A) \rightarrow Y(A)\)</span> and treat it as a function.The properties above then say for any <span class="math inline">\( f:(A&#39;, (Xf)(x)) \rightarrow (A,x)\)</span> in <span class="math inline">\( \mathbb{E}(X)\)</span>, <span class="math inline">\( (Yf)(\overline{\alpha}_A(x)) = \overline{\alpha}_{A&#39;}((Xf)(x))\)</span>, that is to say the following diagram commutes for all <span class="math inline">\( f:A&#39; \rightarrow A\)</span> in <span class="math inline">\( \mathbb{A}\)</span>:</p>
<p><img src="./Images/2018/06/img4.png" /></p>
<p>This shows that <span class="math inline">\( \overline{\alpha}:X \rightarrow Y\)</span> is a natural transformation. As all of the above is equivalent, we see that a cocone on <span class="math inline">\( Y\)</span> is the same as a map from <span class="math inline">\( X\)</span> into <span class="math inline">\( Y\)</span>, hence <span class="math inline">\( X\)</span> is the colimit of <span class="math inline">\( H_\bullet \circ P\)</span>. We can write this as equivalence formally as</p>
<p><span class="math inline">\( [\mathbb{E}(X), [\mathbb{A}^{op}, \mathbf{Set}]](H_\bullet \circ P, \Delta Y) \cong [\mathbb{A}^{op}, \mathbf{Set}](X,Y)\)</span>.</p>
<p>This is an application of the dual of [Equation 6.2, 1].</p>
</div>
<p>The property that morphisms in <span class="math inline">\( \mathbb{E}(X)\)</span> have is vital to this proof and, to myself atleast, shows why we need to use this particular small category.</p>
<p>Given a set <span class="math inline">\( S\)</span>, there is an equivalence of categories <span class="math inline">\( \mathbf{Set}/S \simeq \mathbf{Set}^S\)</span>, where the latter has as objects <span class="math inline">\( S\)</span> indexed tuples of sets. Given <span class="math inline">\( (A, f:A \rightarrow S) \in \mathbf{Set}/S\)</span>, we form the tuple <span class="math inline">\( (f^{-1}(s))_{s \in S}\)</span> and given a tuple <span class="math inline">\( (A_s)_{s \in S}\)</span>, we form the disjoint union <span class="math inline">\( \coprod_{s \in S}A_s\)</span> along with the function <span class="math inline">\( g:\coprod_{s \in S}A_s \rightarrow S\)</span> that sends every element in each <span class="math inline">\( A_s\)</span> to <span class="math inline">\( s\)</span>. This equivalence can be abstracted to categories by the following theorem.</p>
<div class="theorem">
<p>[2, Proposition 1.1.7] Let <span class="math inline">\( \mathbb{A}\)</span> be a small category and <span class="math inline">\( X: \mathbb{A}^{op} \rightarrow \mathbf{Set}\)</span> a presheaf on <span class="math inline">\( \mathbb{A}\)</span>. Then there is an equivalence of categories:</p>
<p><span class="math inline">\( [\mathbb{A}^{op}, \mathbf{Set}]/X \simeq [\mathbb{E}(X)^{op}, \mathbf{Set}]\)</span>.</p>
</div>
<div class="proof">
<p>I will give the functors required and leave the checking of the equivalence out, as it is pretty involved. The definitions of the functors require a proof to show that they are well defined (it needs to be shown that the natural transformations are indeed natural), however as this isn’t too hard, we omit it. First, we define the following functor:</p>
<p><img src="./Images/2018/06/functor.png" /></p>
<p>The functor <span class="math inline">\( \widehat{(F,\alpha)}\)</span> is defined as follows:</p>
<p><img src="./Images/2018/06/functor2.png" /></p>
<p>Where <span class="math inline">\( \widehat{(F,\alpha)}(f)(y) = (Ff)(y)\)</span>. The natural transformation <span class="math inline">\( \hat{\lambda}\)</span> has components <span class="math inline">\( \hat{\lambda}_{(A,x)}:\alpha_A^{-1} \rightarrow \beta_A^{-1}(x)\)</span> with <span class="math inline">\( \hat{\lambda}_{(A,x)}(y) = \lambda_A(y)\)</span>. We now define a map in the other direction:</p>
<p><img src="./Images/2018/06/functor3.png" /></p>
<p>The functor <span class="math inline">\( P_x: \mathbb{A}^{op} \rightarrow \mathbf{Set}\)</span> is defined as <span class="math inline">\( P_x(A) = P(A,x)\)</span>. This can then be made into a functor <span class="math inline">\( \coprod_{x \in X(-)}P_x:\mathbb{A}^{op} \rightarrow \mathbf{Set}\)</span>. The natural transformation <span class="math inline">\( \tilde{P}\)</span> has components defined by the universal property of the coproduct. If <span class="math inline">\( y \in P_x(A)\)</span> then <span class="math inline">\( \tilde{P}_A(y) = x\)</span>. The natural transformation <span class="math inline">\( \tilde{\lambda}\)</span> has components with the following action on <span class="math inline">\( y \in P(A,x)\)</span> - <span class="math inline">\( \tilde{\lambda}_A(y) = \lambda_{(A,x)}(y)\)</span>.</p>
<p>It is shown in the attached pdf that these functors give rise to an equivalence, hence proving the claim.</p>
</div>
<p>In conclusion, the category of elements is vital to proving that any presheaf is actually a colimit of a certain diagram. It also shows that slice categories of presheaf categories can be seen as a presheaf category themselves.</p>
<p><strong>*</strong></p>
<p>(1) T. Leinster, Basic category theory, 2014, 2016.</p>
<p>(2) T. Leinster, Higher operads, higher categories, 2013.</p>
<p>(3) J. Leslie, [Category of elements](/files/category-elemets.pdf)</p>
</section>
<hr>
<script src="https://giscus.app/client.js"
        data-repo="jeslie0/jeslie0.github.io"
        data-repo-id="R_kgDOG3FkcQ"
        data-category="Announcements"
        data-category-id="DIC_kwDOG3Fkcc4CPMWW"
        data-mapping="title"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="light"
        data-lang="en"
        data-loading="lazy"
        crossorigin="anonymous"
        async>
</script>

</article>
]]></description>
    <pubDate>Sat, 30 Jun 2018 00:00:00 UT</pubDate>
    <guid>https://jeslie0.github.com/blog/2018-06-30-Categories-of-elements.html</guid>
    <dc:creator>James Leslie</dc:creator>
</item>
<item>
    <title>Yoneda, Yoneda, Yoneda</title>
    <link>https://jeslie0.github.com/blog/2018-04-23-Yoneda-Yoneda-Yoneda.html</link>
    <description><![CDATA[<head>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <link rel="stylesheet" href="/css/theorem.css" />
</head>
<section class="header">
  Posted on April 23, 2018
  
  by James Leslie
  
</section>
<section>
  <p>The Yoneda Lemma is one of the few ‘theorems’ one learns in a first course on category theory and it is an invaluable tool.</p>
<p>Suppose we have a locally small category <span class="math inline">\( \mathcal{A}\)</span>, then for any two objects <span class="math inline">\( A, B\)</span> there is a set of maps from <span class="math inline">\( A\)</span> to <span class="math inline">\( B\)</span>, denoted <span class="math inline">\( \mathcal{A}(A,B)\)</span>. We can make this into a functor by forgetting about the domain. We define the following functor:</p>
<p><span class="math inline">\( H_B:\mathcal{A}^{op} \rightarrow \mathbf{Set}\)</span>,</p>
<p>such that <span class="math inline">\( A \mapsto H_B(A) = \mathcal{A}(A, B)\)</span> and <span class="math inline">\((f:A \rightarrow C) \mapsto (H_A(f):H_A(C) \rightarrow H_A(A))\)</span>. Given any map <span class="math inline">\( g:C \rightarrow A\)</span>, <span class="math inline">\( (H_A(f))(g) = g \circ f:A \rightarrow A\)</span>. We can go further however, by removing our choice of <span class="math inline">\(A\)</span>. We define a functor</p>
<p><span class="math inline">\(H_\cdot:\mathcal{A} \rightarrow [\mathcal{A}^\text{op}, \mathbf{Set}]\)</span>,</p>
<p>where <span class="math inline">\( A \mapsto H_A\)</span> and <span class="math inline">\( (f:A \rightarrow B) \mapsto (H_f:H_A \rightarrow H_B)\)</span>, where <span class="math inline">\( H_f\)</span> is a natural transformation. For any <span class="math inline">\( C \in \mathcal{A}\)</span>, the <span class="math inline">\( C\)</span> component of <span class="math inline">\( H_f\)</span> is a function <span class="math inline">\( (H_f)_C:H_A(C) \rightarrow H_B(C)\)</span> such that for any map <span class="math inline">\( g:C \rightarrow A\)</span>, <span class="math inline">\( ((H_f)_C)(g) = f \circ g:C \rightarrow B\)</span>.</p>
<p>The functor <span class="math inline">\( H_\cdot\)</span> is known as the Yoneda embedding. It comes hand in hand with the Yoneda Lemma.</p>
<h1 id="yoneda-lemma">Yoneda lemma</h1>
<div class="theorem">
<p>Let <span class="math inline">\(\mathcal{A}\)</span> be a locally small category. Then </p>
<p><span class="math inline">\([\mathcal{A}^\text{op}, \mathbf{Set}](H_A, X) \cong X(A)\)</span>,</p>
<p>naturally in <span class="math inline">\(A \in \mathcal{A}\)</span> and <span class="math inline">\( X \in  [\mathcal{A}^\text{op}, \mathbf{Set}]\)</span>.</p>
</div>
<p>There are many discussions on the importance of Yoneda, however we shall skip over them and instead look at the Yoneda embedding. This functor can only really be called an embedding if it is both full and faithful. This is a trivial result of the Yoneda lemma, however it is not necessary to invoke the lemma and it can be proven without it.</p>
<h1 id="yoneda-embedding-is-full-and-faithful">Yoneda embedding is full and faithful</h1>
<p>Let <span class="math inline">\( A, A&#39; \in \mathcal{A}\)</span>, and let <span class="math inline">\( \alpha:H_A \rightarrow H_{A&#39;}\)</span> be a natural transformation. We need to find a map <span class="math inline">\( f:A \rightarrow A&#39;\)</span> such that <span class="math inline">\( \alpha = H_f\)</span>. Looking at the <span class="math inline">\( A\)</span> component of <span class="math inline">\( \alpha\)</span> gives us a function</p>
<p><span class="math inline">\(\alpha_A:H_A(A) \rightarrow H_{A&#39;}(A)\)</span>.</p>
<p>We apply this to the identity map on <span class="math inline">\( A\)</span> to get a map <span class="math inline">\( \alpha_A(1_A):A \rightarrow A&#39;\)</span>. I claim that this is the required map. For notation, we shall call it <span class="math inline">\( f\)</span>. It is the case that <span class="math inline">\( H_f = \alpha\)</span> if and only if each component is equal, that is <span class="math inline">\( (H_f)_B = \alpha_B\)</span> for all objects <span class="math inline">\( B \in \mathcal{A}\)</span>. Choosing an arbitrary <span class="math inline">\( B \in \mathcal{A}\)</span>, as both  <span class="math inline">\( (H_f)_B\)</span> and <span class="math inline">\( \alpha_B\)</span> are functions, they are equal if and only if they take the same values on the same inputs. Recall the domains and codomains of the functions:</p>
<p><span class="math inline">\((H_f)_B, \alpha_B: H_A(B) \rightarrow H_{A&#39;}(B)\)</span>.</p>
<p>Take an arbitrary map <span class="math inline">\( g:B \rightarrow A\)</span>. Then <span class="math inline">\( ((H_f)_B)(g) = f \circ g = \alpha_A(1_A) \circ g\)</span>. We need to show that this is <span class="math inline">\( \alpha_B(g)\)</span>. This follows from the naturality of <span class="math inline">\( \alpha\)</span>. Indeed, for naturality gives us the following commutative square:</p>
<p><span class="math display">\[\begin{tikzcd}
H_A(A) \arrow[r, &quot;- \circ g&quot;] \arrow[d, &quot;\alpha_A&quot;&#39;] &amp; H_A(B) \arrow[d, &quot;\alpha_B&quot;] \\
H_{A&#39;}(A) \arrow[r, &quot;-\circ g&quot;&#39;]                     &amp; H_A&#39;(B)                     
\end{tikzcd}\]</span></p>
<p>These functions take the following on <span class="math inline">\( 1_A\)</span>:</p>
<p><span class="math display">\[\begin{tikzcd}
1_A \arrow[dd, maps to] \arrow[r, maps to] &amp; g \arrow[d, maps to]  \\
                                           &amp; \alpha_B(g)           \\
\alpha_A(1_A) \arrow[r, maps to]           &amp; \alpha_A(1_A) \circ g
\end{tikzcd}\]</span></p>
<p>This says that <span class="math inline">\( \alpha_B(g) = \alpha_A(1_A) \circ g\)</span>. This means <span class="math inline">\( \alpha_B\)</span> and <span class="math inline">\( (H_f)_B\)</span> are equal as functions, which means that <span class="math inline">\( H_f = \alpha\)</span>. which by our reasoning above shows that <span class="math inline">\( \alpha = H_f\)</span>, hence <span class="math inline">\( H_\cdot\)</span> is full.</p>
<p>For faithfulness, again fix <span class="math inline">\( A, A&#39; \in \mathcal{A}\)</span> and consider two natural transformations <span class="math inline">\( H_f, H_g: H_A \rightarrow H_A&#39;\)</span>. Supposing <span class="math inline">\( H_f = H_g\)</span>, we need to show that <span class="math inline">\( f=g\)</span>. As <span class="math inline">\( H_f = H_g\)</span>, <span class="math inline">\( (H_f)_A = (H_g)_A)\)</span>. These are both functions, so we apply them to <span class="math inline">\( 1_A\)</span> giving us <span class="math inline">\( f \circ 1_A = g \circ 1_A\)</span>, therefore <span class="math inline">\( f = g\)</span>, proving faithfulness.</p>
<p>Despite not explicitly using the Yoneda lemma, everything we have done is used in the proof of it. There is one more result that helps capture the idea behind the proof for Yoneda.</p>
<h1 id="yoneda-embedding-is-injective-on-isomorphism-classes">Yoneda embedding is injective on isomorphism classes</h1>
<p>Suppose for two objects <span class="math inline">\( A, B \in \mathcal{A}\)</span> that <span class="math inline">\( H_A \cong H_{B}\)</span>. This means that we have two natural isomorphisms:</p>
<p><span class="math inline">\(\alpha:H_A \rightarrow H_B, \qquad \beta:H_B \rightarrow H_A\)</span></p>
<p>which are inverses to each other. By reasoning from above, we a map <span class="math inline">\( \alpha_A(1_A):A \rightarrow B\)</span> and <span class="math inline">\( \beta_B(1_B):B \rightarrow A\)</span>. For notation, we shall call <span class="math inline">\( \alpha_A(1_A) = f\)</span> and <span class="math inline">\( \beta_B(1_B) = g\)</span>. Again from above, we see that <span class="math inline">\( \alpha_B(g) = \alpha_A(1_A) \circ g\)</span>. Substituting for <span class="math inline">\( g\)</span> gives that <span class="math inline">\( \alpha_B(\beta_B(1_B)) = \alpha_A(1_A) \circ \beta_B(1_B)\)</span>. As <span class="math inline">\( \alpha\)</span> and <span class="math inline">\( \beta\)</span> are inverses, their components are mutual inverses. This means <span class="math inline">\( \alpha_B(\beta_B(1_B)) = 1_B\)</span>, so <span class="math inline">\( \alpha_A(1_A) \circ \beta_B(1_B) = 1_B\)</span>. A similar argument shows that <span class="math inline">\( \beta_B(1_B) \circ \alpha_A(1_A) = 1_A\)</span>, hence <span class="math inline">\( \alpha_A(1_A)\)</span> and <span class="math inline">\( \beta_B(1_B)\)</span> are isomorphisms. Therefore, <span class="math inline">\( A \cong B\)</span>.</p>
<p>The results from this post are from Chapter 4 of Tom Leinster’s Basic Category Theory textbook, which can be found <a href="https://arxiv.org/abs/1612.09375">here</a>.</p>
</section>
<hr>
<script src="https://giscus.app/client.js"
        data-repo="jeslie0/jeslie0.github.io"
        data-repo-id="R_kgDOG3FkcQ"
        data-category="Announcements"
        data-category-id="DIC_kwDOG3Fkcc4CPMWW"
        data-mapping="title"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="light"
        data-lang="en"
        data-loading="lazy"
        crossorigin="anonymous"
        async>
</script>

</article>
]]></description>
    <pubDate>Mon, 23 Apr 2018 00:00:00 UT</pubDate>
    <guid>https://jeslie0.github.com/blog/2018-04-23-Yoneda-Yoneda-Yoneda.html</guid>
    <dc:creator>James Leslie</dc:creator>
</item>
<item>
    <title>Monoidal Categories</title>
    <link>https://jeslie0.github.com/blog/2018-04-15-Monoidal-Categories.html</link>
    <description><![CDATA[<head>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <link rel="stylesheet" href="/css/theorem.css" />
</head>
<section class="header">
  Posted on April 15, 2018
  
  by James Leslie
  
</section>
<section>
  <p>In mathematics, we are familiar with putting structure on sets, for example a group is a set with a binary operation satisfying certain properties. We can extend this notion to categories. The first examples I came across in my studies were monoidal categories, which are used to abstract the notion of a tensor product, and have deep ties to quantum mechanics and physics.</p>
<div class="definition">
<p>A <em>monoidal category</em> is a category <span class="math inline">\(\mathcal{C}\)</span> with a functor <span class="math inline">\( \otimes: \mathcal{C} \times \mathcal{C} \rightarrow \mathcal{C}\)</span>, an object <span class="math inline">\( I \in \mathcal{C}\)</span> called the unit and the following natural isomorphisms, written in terms of their components:</p>
<ol>
<li>An associator <span class="math inline">\(\alpha_{A,B,C}: (A \otimes B) \otimes C \rightarrow A \otimes (B \otimes C)\)</span>,</li>
<li>A left unitor <span class="math inline">\(\lambda_A: I \otimes A \rightarrow A\)</span>,</li>
<li>A right unitor <span class="math inline">\(\rho_A: A \otimes I \rightarrow A\)</span>.</li>
</ol>
<p>These maps all have to satisfy the following diagrams, aptly named the triangle and pentagon identities.</p>
<p><span class="math display">\[\begin{tikzcd}
                                                                                                                                    &amp; (A \otimes I) \otimes B \arrow[rr, &quot;{\alpha_{A, I , B}}&quot;] \arrow[rd, &quot;\rho_A \otimes \text{id}_B&quot;&#39;] &amp;                                                                                &amp; A \otimes (I \otimes B) \arrow[ld, &quot;\text{id}_A \otimes \lambda_B&quot;]                    &amp;                                     \\
                                                                                                                                    &amp;                                                                                                     &amp; A \otimes B                                                                    &amp;                                                                                        &amp;                                     \\
                                                                                                                                    &amp; (A \otimes (B \otimes C)) \otimes D \arrow[rr, &quot;{\alpha_{A, B \otimes C,D}}&quot;]                       &amp;                                                                                &amp; A \otimes ((B \otimes C) \otimes D) \arrow[rd, &quot;{\text{id}_A \otimes \alpha_{B,C,d}}&quot;] &amp;                                     \\
((A \otimes B)\otimes C) \otimes D \arrow[ru, &quot;{\alpha_{A,B,C} \otimes \text{id}_D}&quot;] \arrow[rrd, &quot;{\alpha_{A \otimes B, C , D}}&quot;&#39;] &amp;                                                                                                     &amp;                                                                                &amp;                                                                                        &amp; A \otimes (B \otimes (C \otimes D)) \\
                                                                                                                                    &amp;                                                                                                     &amp; (A \otimes B) \otimes (C \otimes D) \arrow[rru, &quot;{\alpha_{A,B,C \otimes D}}&quot;&#39;] &amp;                                                                                        &amp;                                    
                                                                                                                                    \end{tikzcd}\]</span></p>
</div>
<p>These two diagrams remarkably lead to a coherence theorem which states that every well formed formula built from <span class="math inline">\(\alpha, \lambda, \rho\)</span> and their inverses holds. This gives us for free that <span class="math inline">\( \rho_I = \lambda_I\)</span>, which would otherwise be very painful to prove.</p>
<p>The classic example of a monoidal category is <span class="math inline">\( \mathbf{Hilb}\)</span>, the category of Hilbert spaces with morphisms as bounded linear maps. The tensor functor simply gives the tensor product of two Hilbert spaces and the unit object is <span class="math inline">\( \mathbb{C}\)</span>, the complex numbers. The natural transformations are given in the obvious way. We can turn <span class="math inline">\( \mathbf{Set}\)</span> into a monoidal category by having the <span class="math inline">\( \otimes\)</span> functor give the Cartesian product of two sets and having the terminal object 1 as the unit.</p>
<p>The study of both <span class="math inline">\( \mathbf{Hilb}\)</span> and <span class="math inline">\( \mathbf{Set}\)</span> are useful for physics. The former is used to formalize quantum mechanics and the latter classical physics. One property that <span class="math inline">\(\mathbf{Hilb}\)</span> has that <span class="math inline">\(\mathbf{Set}\)</span> doesn’t is the existence of a zero object. This is an object, denoted <span class="math inline">\(0\)</span>, which is both initial and terminal, that is, given any other object <span class="math inline">\( A\)</span>, there is exactly one morphism <span class="math inline">\( 0 \rightarrow A\)</span> and exactly one morphism <span class="math inline">\( A \rightarrow 0\)</span>. It isn’t hard to see that <span class="math inline">\( \mathbf{Hilb}\)</span>, the zero object is simply the Hilbert space consisting of just a zero vector. It is also not difficult to show that <span class="math inline">\( \mathbf{Set}\)</span> doesn’t have a zero object, since if it did it would need to be isomorphic to both the one element set and the empty set, which is impossible.</p>
<p>It is easy to see that in <span class="math inline">\( \mathbf{Hilb}\)</span>, we have <span class="math inline">\( 0 \otimes 0 \cong 0\)</span>. This is true for all monoidal categories with a zero object, as we shall now prove. I highly recommend trying this exercise for yourself first!</p>
<p>We have the following unique arrows: <span class="math inline">\( f: I \rightarrow 0\)</span> and <span class="math inline">\( g:0 \rightarrow I\)</span>. These give rise to maps <span class="math inline">\( f \otimes 1_0:I \otimes 0 \rightarrow 0 \otimes 0\)</span> and <span class="math inline">\( g \otimes 1_0: 0 \otimes 0 \rightarrow I \otimes0\)</span>. We then get the following composites:</p>
<ol>
<li><span class="math inline">\( 0 \xrightarrow{\lambda_0^{-1}} I \otimes 0 \xrightarrow{f \otimes 1_0} 0 \otimes 0\)</span>,</li>
<li><span class="math inline">\(0 \otimes 0 \xrightarrow{g \otimes 1_0} I \otimes 0 \xrightarrow{\lambda_0} 0\)</span>.</li>
</ol>
<p>As <span class="math inline">\( 0\)</span> is a zero-object, there is only one map <span class="math inline">\( 0 \rightarrow 0\)</span>, namely the identity map <span class="math inline">\( 1_0\)</span>. This means</p>
<p><span class="math inline">\(\left(\lambda_0 \circ (g \otimes 1_0)\right) \circ \left((f \otimes 1_0) \circ \lambda_0^{-1} \right)= 1_0\)</span>.</p>
<p>We also see that <span class="math inline">\( f \circ g:0 \rightarrow 0\)</span>, so <span class="math inline">\( f \circ g = 1_0\)</span>. We can then build the following commuting square:</p>
<p><span class="math display">\[ \begin{tikzcd}
0 \arrow[r, &quot;g&quot;] \arrow[d, &quot;1_0&quot;&#39;] &amp; I \arrow[d, &quot;1_I&quot;] \\
0                                  &amp; I \arrow[l, &quot;f&quot;]  
\end{tikzcd} \]</span></p>
<p>We can apply the functor <span class="math inline">\( - \otimes 0\)</span> to this square to get the following square:
<span class="math display">\[\begin{tikzcd}
0 \otimes 0 \arrow[r, &quot;g \otimes 1_0&quot;] \arrow[d, &quot;1_0 \otimes 1_0&quot;&#39;] &amp; I \otimes 0 \arrow[d, &quot;1_I&quot;]           \\
0 \otimes 0                                                          &amp; I \otimes 0 \arrow[l, &quot;f \otimes 1_0&quot;]
\end{tikzcd}\]</span></p>
<p>Factoring <span class="math inline">\( 1_{I \otimes 0} = \lambda_0^{-1} \circ \lambda_0\)</span> gives the following diagram:</p>
<p><span class="math display">\[\begin{tikzcd}
0 \otimes 0 \arrow[r, &quot;g \otimes 1_0&quot;] \arrow[d, &quot;1_0 \otimes 1_0&quot;&#39;] &amp; I \otimes 0 \arrow[d, &quot;1_I&quot;] \arrow[r, &quot;\lambda_0&quot;] &amp; 0 \arrow[ld, &quot;\lambda_0^{-1}&quot;] \\
0 \otimes 0                                                          &amp; I \otimes 0 \arrow[l, &quot;f \otimes 1_0&quot;]              &amp;                               
\end{tikzcd}\]</span></p>
<p>We also know that <span class="math inline">\( 1_0 \otimes 1_0 = 1_{0 \otimes0}\)</span>, from the tensor product functor. As this commutes, we have <span class="math inline">\( \left((f \otimes 1_0) \circ \lambda_0^{-1} \right) \circ  \left(\lambda_0 \circ (g \otimes 1_0)\right) = 1_{0\otimes0}\)</span>. This results in the maps (1) and (2) being mutual inverses, hence <span class="math inline">\( 0 \cong 0 \otimes 0\)</span>, as required.</p>
<p>This is only the tip of the iceberg when it comes to monoidal categories, for example, we might want <span class="math inline">\( A \otimes B \cong B \otimes A\)</span>, in which case we need to look at braided monoidal categories. This post has been inspired by revision for one of my exams. The content is from lecture notes by my lecturer Chris Heunen which can (currently) be found <a href="http://www.inf.ed.ac.uk/teaching/courses/cqi/">here</a>.</p>
</section>
<hr>
<script src="https://giscus.app/client.js"
        data-repo="jeslie0/jeslie0.github.io"
        data-repo-id="R_kgDOG3FkcQ"
        data-category="Announcements"
        data-category-id="DIC_kwDOG3Fkcc4CPMWW"
        data-mapping="title"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="light"
        data-lang="en"
        data-loading="lazy"
        crossorigin="anonymous"
        async>
</script>

</article>
]]></description>
    <pubDate>Sun, 15 Apr 2018 00:00:00 UT</pubDate>
    <guid>https://jeslie0.github.com/blog/2018-04-15-Monoidal-Categories.html</guid>
    <dc:creator>James Leslie</dc:creator>
</item>

    </channel>
</rss>
