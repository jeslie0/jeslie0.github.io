<!doctype html><html lang=en><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1"><title>James Leslie - Categories of elements</title><link rel=stylesheet href=../css/simple.css><link rel=stylesheet href=../css/navbar.css><link rel=stylesheet href=../css/misc.css><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.2.0/css/all.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css integrity=sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn crossorigin=anonymous><div class=topnav><a href=../index.html>Home</a>
<a href=../blog.html>Blog</a>
<a href=../contact.html>Contact</a></div><main role=main><h1>Categories of elements</h1><link rel=stylesheet href=../css/theorem.css><section class=header>Posted on June 30, 2018
by James Leslie</section><section><p>When learning about colimits and presheaf categories, one often meets a category of elements. The definition of the category isn’t particularly hard to understand or remember; however, I didn’t immediately have an intuition for why it is useful or where the definition came from. This has lead me to play with it and try to understand some properties of it.<div class=definition><p>Given a locally small category <span class="math inline">\( \mathbb{A}\)</span> and a functor <span class="math inline">\( X:\mathbb{A}^{op} \rightarrow \mathbf{Set}\)</span>, the category of elements of <span class="math inline">\( X\)</span>, denoted <span class="math inline">\( \mathbb{E}(X)\)</span> or <span class="math inline">\( \int^\mathbb{A} X\)</span>, is defined as follows:<ul><li>Objects are pairs <span class="math inline">\( (A \in \mathbb{A}, x \in X(A))\)</span>,<li>Morphisms <span class="math inline">\( f:(A, x) \rightarrow (A',x')\)</span> are maps <span class="math inline">\( f:A \rightarrow A' \in \mathbb{A}\)</span> such that <span class="math inline">\( (Xf)(x')=x\)</span>.</ul></div><p>Every category of elements has a projection functor <span class="math inline">\( P:\mathbb{E}(x) \rightarrow \mathbb{A}\)</span> associated with it that sends <span class="math inline">\( (A,x) \mapsto A\)</span> and <span class="math inline">\( f \mapsto f\)</span>. There is a useful property tucked away in the definition: for any <span class="math inline">\( \mathbb{A}\)</span>-arrow <span class="math inline">\( f:A' \rightarrow A\)</span>, there is a unique element <span class="math inline">\( x' \in X(A')\)</span> such that there is an <span class="math inline">\( \mathbb{E}(X)\)</span>-morphism <span class="math inline">\( f:(A',x') \rightarrow (A, x)\)</span>, namely <span class="math inline">\( x' = (Xf)(x)\)</span>. As a result of this, we will often write morphism as <span class="math inline">\( f:(A', (Xf)(x)) \rightarrow (A,x)\)</span>. Another observation is that we can write <span class="math inline">\( \mathbb{E}(X)\)</span> as a comma category.<div class=lemma><p>There is an isomorphism <span class="math inline">\( \mathbb{E}(X) \cong (1 \Rightarrow X)\)</span>.</div><div class=proof><p>We look at the comma category for the following diagram:<p><img src=./Images/2018/06/comma.png><p>The double stroke 1 is the terminal category and the functor  1 is the functor that selects the terminal set. This category has as objects, pairs <span class="math inline">\( (A \in \mathbb{A}, x:1 \rightarrow X(A))\)</span> and morphisms <span class="math inline">\( f:(A,x) \rightarrow (A',x')\)</span> are commuting triangles:<p><img src=./Images/2018/06/comma11.png><p>That this triangle commutes is the same as stating <span class="math inline">\( x = (Xf)(x')\)</span>, which is the condition above.</div><p>We can use the category of elements to relate representablity to the existence of a terminal object.<div class=proposition><p>[1, Exercise 6.2.23] Let <span class="math inline">\( X\)</span> be a presheaf on a locally small category. <span class="math inline">\( X\)</span> is representable if and only if <span class="math inline">\( \mathbb{E}(X)\)</span> has a terminal object.</div><div class=proof><p>The category <span class="math inline">\( \mathbb{E}(X)\)</span> has a terminal object if and only if there is an object <span class="math inline">\( (A, x)\)</span> such that for any <span class="math inline">\( (A',x')\)</span>, there is exactly one morphism <span class="math inline">\( f:(A',x') \rightarrow (A,x)\)</span>. This is equivalent to there being an <span class="math inline">\( A \in \mathbb{A}\)</span> and <span class="math inline">\( x \in X(A)\)</span> such that for all <span class="math inline">\( A' \in \mathbb{A}\)</span>, <span class="math inline">\( x \in X(A')\)</span>, there is a unique morphism <span class="math inline">\( f:A' \rightarrow A\)</span> such that <span class="math inline">\( (Xf)(x) = x'\)</span>. This condition is equivalent to <span class="math inline">\( X\)</span> being representable, by [Corollary 4.3.2, 1].</div><p>One of the most important uses of the category of elements is to show that any presheaf is a colimit of a certain diagram, in a canonical way. This is the main purpose of the category of elements in [1, Definition 6.2.16].<div class=proposition><p>[1, Theorem 6.2.17] *Let <span class="math inline">\( \mathbb{A}\)</span> be small and <span class="math inline">\( X:\mathbb{A}^{op} \rightarrow \mathbf{Set}\)</span> a presheaf. Then <span class="math inline">\( X\)</span> is the colimit of the following diagram:<p><img src=./Images/2018/06/diagram.png><p>That is, <span class="math inline">\( X \cong \lim{\rightarrow \mathbb{E}(X)}(H\bullet \circ P)\)</span>.</div><div class=proof><p>We should first note that this does make sense; as <span class="math inline">\( \mathbb{A}\)</span> is small, so is <span class="math inline">\( \mathbb{E}(X)\)</span>, hence a colimit does indeed exist.<p>We know that presheaf categories have all (small) limits and colimits, so a colimit of <span class="math inline">\( H_\bullet \circ P\)</span> exists. Let <span class="math inline">\( Y \in [\mathbb{A}^{op}, \mathbf{Set}]\)</span> be a presheaf and let <span class="math inline">\( (\alpha_{(A,x)}:(H_\bullet \circ P)(A,x) \rightarrow Y)_{(A,x)\in \mathbb{E}(X)}\)</span> be a cocone on <span class="math inline">\( H_\bullet \circ P\)</span> with vertex <span class="math inline">\( Y\)</span>. We can simply this to have <span class="math inline">\( (\alpha_{(A,x)}:(H_A \rightarrow Y)_{(A,x)\in \mathbb{E}(X)}\)</span>. This is a family of natural transformations, so for all <span class="math inline">\( f:(A',x') \rightarrow (A, x)\)</span> in <span class="math inline">\( \mathbb{E}(X)\)</span>, the folowing diagram commutes<p><img src=./Images/2018/06/img1.png><p>By the Yoneda lemma, every natural transformation <span class="math inline">\( \alpha_{(A,x)}:H_A \rightarrow Y\)</span> corresponds to a unique element <span class="math inline">\( (\alpha_{(A,x)})_A(1_A) \in Y(A)\)</span>, which we shall denote <span class="math inline">\( y_{(A,x)}\)</span>. As the diagram above commutes, it commutes for all <span class="math inline">\( A \in \mathbb{A}\)</span>, so in particular it commutes for <span class="math inline">\( A'\)</span>. This gives us the following:<p><img src=./Images/2018/06/img2.png><p>This gives us <span class="math inline">\( y_{(A',(Xf)(x))} = (\alpha_{(A,x)})_{A'}(f)\)</span>. As <span class="math inline">\( \alpha_{(A,x)}\)</span> is a natural transformation, the following square commutes:<p><img src=./Images/2018/06/img3.png><p>This gives us <span class="math inline">\( (Yf)(y_{(A,x)}) = (\alpha_{(A,x)})_{A'}(f)\)</span>. Combining this with the above we see that a cocone on <span class="math inline">\( Y\)</span> is a collection of elements <span class="math inline">\( (y_{(A,x)})_{(A,x)\in \mathbb{E}(X)}\)</span> such that for any <span class="math inline">\( f:(A',(Xf)(x)) \rightarrow (A,x)\)</span> in <span class="math inline">\( \mathbb{E}(X)\)</span>, <span class="math inline">\( (Yf)(y_{(A,x)}) = y_{(A', (Xf)(x))}\)</span>.<p>An equivalent way to write <span class="math inline">\( y_{(A,x)}\)</span> is <span class="math inline">\( \overline{\alpha}_A(x):X(A) \rightarrow Y(A)\)</span> and treat it as a function.The properties above then say for any <span class="math inline">\( f:(A', (Xf)(x)) \rightarrow (A,x)\)</span> in <span class="math inline">\( \mathbb{E}(X)\)</span>, <span class="math inline">\( (Yf)(\overline{\alpha}_A(x)) = \overline{\alpha}_{A'}((Xf)(x))\)</span>, that is to say the following diagram commutes for all <span class="math inline">\( f:A' \rightarrow A\)</span> in <span class="math inline">\( \mathbb{A}\)</span>:<p><img src=./Images/2018/06/img4.png><p>This shows that <span class="math inline">\( \overline{\alpha}:X \rightarrow Y\)</span> is a natural transformation. As all of the above is equivalent, we see that a cocone on <span class="math inline">\( Y\)</span> is the same as a map from <span class="math inline">\( X\)</span> into <span class="math inline">\( Y\)</span>, hence <span class="math inline">\( X\)</span> is the colimit of <span class="math inline">\( H_\bullet \circ P\)</span>. We can write this as equivalence formally as<p><span class="math inline">\( [\mathbb{E}(X), [\mathbb{A}^{op}, \mathbf{Set}]](H_\bullet \circ P, \Delta Y) \cong [\mathbb{A}^{op}, \mathbf{Set}](X,Y)\)</span>.<p>This is an application of the dual of [Equation 6.2, 1].</div><p>The property that morphisms in <span class="math inline">\( \mathbb{E}(X)\)</span> have is vital to this proof and, to myself atleast, shows why we need to use this particular small category.<p>Given a set <span class="math inline">\( S\)</span>, there is an equivalence of categories <span class="math inline">\( \mathbf{Set}/S \simeq \mathbf{Set}^S\)</span>, where the latter has as objects <span class="math inline">\( S\)</span> indexed tuples of sets. Given <span class="math inline">\( (A, f:A \rightarrow S) \in \mathbf{Set}/S\)</span>, we form the tuple <span class="math inline">\( (f^{-1}(s))_{s \in S}\)</span> and given a tuple <span class="math inline">\( (A_s)_{s \in S}\)</span>, we form the disjoint union <span class="math inline">\( \coprod_{s \in S}A_s\)</span> along with the function <span class="math inline">\( g:\coprod_{s \in S}A_s \rightarrow S\)</span> that sends every element in each <span class="math inline">\( A_s\)</span> to <span class="math inline">\( s\)</span>. This equivalence can be abstracted to categories by the following theorem.<div class=theorem><p>[2, Proposition 1.1.7] Let <span class="math inline">\( \mathbb{A}\)</span> be a small category and <span class="math inline">\( X: \mathbb{A}^{op} \rightarrow \mathbf{Set}\)</span> a presheaf on <span class="math inline">\( \mathbb{A}\)</span>. Then there is an equivalence of categories:<p><span class="math inline">\( [\mathbb{A}^{op}, \mathbf{Set}]/X \simeq [\mathbb{E}(X)^{op}, \mathbf{Set}]\)</span>.</div><div class=proof><p>I will give the functors required and leave the checking of the equivalence out, as it is pretty involved. The definitions of the functors require a proof to show that they are well defined (it needs to be shown that the natural transformations are indeed natural), however as this isn’t too hard, we omit it. First, we define the following functor:<p><img src=./Images/2018/06/functor.png><p>The functor <span class="math inline">\( \widehat{(F,\alpha)}\)</span> is defined as follows:<p><img src=./Images/2018/06/functor2.png><p>Where <span class="math inline">\( \widehat{(F,\alpha)}(f)(y) = (Ff)(y)\)</span>. The natural transformation <span class="math inline">\( \hat{\lambda}\)</span> has components <span class="math inline">\( \hat{\lambda}_{(A,x)}:\alpha_A^{-1} \rightarrow \beta_A^{-1}(x)\)</span> with <span class="math inline">\( \hat{\lambda}_{(A,x)}(y) = \lambda_A(y)\)</span>. We now define a map in the other direction:<p><img src=./Images/2018/06/functor3.png><p>The functor <span class="math inline">\( P_x: \mathbb{A}^{op} \rightarrow \mathbf{Set}\)</span> is defined as <span class="math inline">\( P_x(A) = P(A,x)\)</span>. This can then be made into a functor <span class="math inline">\( \coprod_{x \in X(-)}P_x:\mathbb{A}^{op} \rightarrow \mathbf{Set}\)</span>. The natural transformation <span class="math inline">\( \tilde{P}\)</span> has components defined by the universal property of the coproduct. If <span class="math inline">\( y \in P_x(A)\)</span> then <span class="math inline">\( \tilde{P}_A(y) = x\)</span>. The natural transformation <span class="math inline">\( \tilde{\lambda}\)</span> has components with the following action on <span class="math inline">\( y \in P(A,x)\)</span> - <span class="math inline">\( \tilde{\lambda}_A(y) = \lambda_{(A,x)}(y)\)</span>.<p>It is shown in the attached pdf that these functors give rise to an equivalence, hence proving the claim.</div><p>In conclusion, the category of elements is vital to proving that any presheaf is actually a colimit of a certain diagram. It also shows that slice categories of presheaf categories can be seen as a presheaf category themselves.<p><strong>*</strong><p>(1) T. Leinster, Basic category theory, 2014, 2016.<p>(2) T. Leinster, Higher operads, higher categories, 2013.<p>(3) J. Leslie, [Category of elements](/files/category-elemets.pdf)</section><hr><script src=https://giscus.app/client.js data-repo=jeslie0/jeslie0.github.io data-repo-id=R_kgDOG3FkcQ data-category=Announcements data-category-id=DIC_kwDOG3Fkcc4CPMWW data-mapping=title data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=en data-loading=lazy crossorigin=anonymous async></script></main><footer><p>Site made with ♥ using <a href=https://orgmode.org/>org-mode</a> and <a href=https://jaspervdj.be/hakyll>hakyll</a><p><a href=../rss.xml><i class="fas fa-rss-square"></i></a><p>Page updated with commit 627c428 on 2023-07-14, by James Leslie</footer><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js integrity=sha384-cpW21h6RZv/phavutF+AuVYrr+dA8xD9zs6FwLpaCct6O9ctzYFfFr4dgmgccOTx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload=renderMathInElement(document.body)></script>